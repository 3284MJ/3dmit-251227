<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Debug Ver.</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0e0e0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #status-log {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            pointer-events: none; border-radius: 4px;
        }

        /* エモーションポップ */
        #emote-pop {
            display: none; position: absolute;
            font-size: 40px; font-weight: bold; color: #ff4757;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            pointer-events: none; z-index: 500;
        }
    </style>
</head>
<body>
    <div id="status-log">Status: Initializing...</div>
    <div id="emote-pop">！</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const logEl = document.getElementById('status-log');
        function debugLog(msg) { logEl.innerText = msg; console.log(msg); }

        // --- シーン設定 ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        scene.fog = new THREE.Fog(0xe0e0e0, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const DEFAULT_CAM_POS = new THREE.Vector3(0, 6, 12);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enabled = false; // オープニング中は無効

        // ライト
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // 地面
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(15, 64),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 変数 ---
        let mixer;
        let model;
        let actions = []; // 配列で管理 (0:Idle, 1:Jump, 2:Special, 3:Soccer)
        let activeAction = null;
        let soccerBall = null;
        let rightHandBone = null;
        
        // フラグ
        let isOpening = true;
        let isProcessing = false;
        let isMoving = false;

        // 入力用
        let tapTimer = null;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        // 影
        const blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ color:0x000000, transparent: true, opacity: 0.3, depthWrite: false })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        scene.add(blobShadow);

        // 旗
        const flagGroup = new THREE.Group();
        flagGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 })));
        const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
        cloth.position.set(0.2, 0.4, 0);
        flagGroup.add(cloth);
        flagGroup.visible = false;
        scene.add(flagGroup);

        // --- ロード処理 ---
        const loader = new GLTFLoader();
        loader.load('./model.glb', (gltf) => {
            model = gltf.scene;
            model.traverse(c => { if(c.isMesh) c.castShadow = true; });
            scene.add(model);

            // ボーン取得 (Mixamo系名称対応)
            rightHandBone = model.getObjectByName('mixamorigRightHand') || model.getObjectByName('RightHand') || model.getObjectByName('Hand.R');

            mixer = new THREE.AnimationMixer(model);
            
            // アニメーションを配列に格納
            // インデックス順: 0:Idle, 1:Jump, 2:Special, 3:Soccer(New)
            gltf.animations.forEach((clip) => {
                actions.push(mixer.clipAction(clip));
            });

            debugLog(`Loaded: ${actions.length} animations`);

            // 4番目(index 3)の設定
            if (actions[3]) {
                actions[3].setLoop(THREE.LoopOnce);
                actions[3].clampWhenFinished = true;
            }

            runOpening();
        });

        // サッカーボールロード
        function loadSoccerBall() {
            if (soccerBall) return;
            loader.load('./soccer_ball.glb', (gltf) => {
                soccerBall = gltf.scene;
                soccerBall.scale.set(0.2, 0.2, 0.2);
                soccerBall.visible = false;
                if (rightHandBone) {
                    rightHandBone.add(soccerBall);
                    soccerBall.position.set(0.1, 0.05, 0.05); // 位置調整
                } else {
                    scene.add(soccerBall);
                }
                debugLog("Ball Loaded");
            });
        }

        // --- オープニング ---
        async function runOpening() {
            debugLog("Opening Start");

            // 1. 配置
            model.position.set(0, 0, -12);
            model.rotation.set(0, 0, 0);
            
            camera.position.set(0, 1.5, 4);
            controls.target.set(0, 0.8, -12);
            controls.update();

            // 2. アイドリング再生
            const idle = actions[0];
            idle.reset().play();
            activeAction = idle;

            await wait(1000);

            // 3. 「！」表示
            const pop = document.getElementById('emote-pop');
            pop.style.display = 'block';
            updatePopPos();
            await wait(500);
            pop.style.display = 'none';

            await wait(500);

            // 4. 走行開始
            debugLog("Run...");
            const run = actions[0].getClip().name.includes('Motion') ? (actions['走行'] || actions[0]) : actions[0]; 
            // ※モデルのアクション名が不明確なため、index 0 以外でループするものを探すのが確実ですが、
            // 今回はとりあえず actions[0] から遷移させます。
            // もし actions[0] が走行ならそのまま、そうでなければ GLB の構造依存。
            // ここでは簡易的に「フェードして移動」させます。
            
            // もし actions配列に名前があればそれを使う、なければ index 0 (Idle) を使う
            // ここでは GLB の中身を信じて、移動アニメーションっぽく動かします
            // ★重要: もし走行アニメが特定できなければ Idle のまま滑りますが、まずはロジック確認
            
            // 前回のコード同様、走行用アニメを探す試み
            let runAnim = actions.find(a => a.getClip().name.includes('Running') || a.getClip().name.includes('Run') || a.getClip().name === '走行');
            if (!runAnim) runAnim = actions[0]; // なければIdleで滑る

            await fadeTo(runAnim, 0.2);
            isMoving = true;

            // 移動ループ
            while (model.position.z < -2.0) {
                model.position.z += 0.15;
                controls.target.set(0, 0.8, model.position.z);
                controls.update();
                await new Promise(r => requestAnimationFrame(r));
            }

            isMoving = false;
            debugLog("Stop!");

            // ★強制停止と切り替え★
            mixer.stopAllAction(); // 全て止める
            actions[0].reset().play(); // Idleを再生
            activeAction = actions[0];
            mixer.update(0); // 描画更新

            // カメラを定位置へ（演出なしで即座に）
            camera.position.copy(DEFAULT_CAM_POS);
            controls.target.set(0, 0.5, 0);
            controls.update();

            isOpening = false;
            controls.enabled = true;
            debugLog("Ready: Click Model!");
        }

        // --- クリック・タップ処理 ---
        window.addEventListener('pointerup', (e) => {
            if (isOpening || isProcessing || isMoving) return;

            // 座標計算
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // モデル判定
            const hits = raycaster.intersectObject(model, true);
            if (hits.length > 0) {
                // モデルをクリックした
                if (tapTimer) {
                    // ダブルクリック -> アニメーション3 (Special)
                    clearTimeout(tapTimer);
                    tapTimer = null;
                    playSpecialAnim();
                } else {
                    tapTimer = setTimeout(() => {
                        // シングルクリック -> アニメーション4 (Soccer)
                        tapTimer = null;
                        playSoccerAnim();
                    }, 300);
                }
                return;
            }

            // 地面判定
            const grounds = raycaster.intersectObject(ground);
            if (grounds.length > 0) {
                moveTo(grounds[0].point);
            }
        });

        // --- アクション実行 ---

        // ダブルクリック: アニメーション3 (Index 2)
        async function playSpecialAnim() {
            if (!actions[2]) { debugLog("No Anim 3"); return; }
            debugLog("Play: Special (Anim 3)");
            isProcessing = true;

            await fadeTo(actions[2], 0.3);
            
            // 30秒待機とかではなく、一度再生したら戻る設定にします（検証用）
            const dur = actions[2].getClip().duration;
            await wait(dur * 1000);

            await fadeTo(actions[0], 0.5);
            isProcessing = false;
        }

        // シングルクリック: アニメーション4 (Index 3) + サッカーボール
        async function playSoccerAnim() {
            if (!actions[3]) { debugLog("No Anim 4"); return; }
            debugLog("Play: Soccer (Anim 4)");
            isProcessing = true;

            loadSoccerBall(); // ボール読み込み

            await fadeTo(actions[3], 0.3);

            // ボール表示タイミング(簡易)
            setTimeout(() => {
                if (soccerBall) soccerBall.visible = true;
            }, 500);

            const dur = actions[3].getClip().duration;
            await wait(dur * 1000);

            // 少し待ってから戻る
            await wait(1000);
            
            await fadeTo(actions[0], 0.5);
            isProcessing = false;
        }

        // 移動
        async function moveTo(pos) {
            isMoving = true;
            flagGroup.position.copy(pos);
            flagGroup.visible = true;

            // 向き変更
            const targetRot = Math.atan2(pos.x - model.position.x, pos.z - model.position.z);
            model.rotation.y = targetRot;

            // 走る
            const run = actions.length > 1 ? actions[0] : actions[0]; // 仮
            await fadeTo(run, 0.2);

            while(model.position.distanceTo(pos) > 0.1) {
                const dir = new THREE.Vector3().subVectors(pos, model.position).normalize();
                model.position.add(dir.multiplyScalar(0.06));
                
                // カメラ追従
                const t = model.position.clone().setY(0.5);
                controls.target.lerp(t, 0.1);
                controls.update();

                await new Promise(r => requestAnimationFrame(r));
            }

            flagGroup.visible = false;
            isMoving = false;
            
            // カメラ向きに戻る
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            const camRot = Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z);
            model.rotation.y = camRot;

            await fadeTo(actions[0], 0.3);
        }

        // --- ユーティリティ ---
        async function fadeTo(next, time) {
            if (activeAction === next) return;
            if (activeAction) activeAction.fadeOut(time);
            next.reset().setEffectiveWeight(1).fadeIn(time).play();
            activeAction = next;
            // 少し待ってフェードを反映させる
            await wait(time * 1000);
        }

        function wait(ms) {
            return new Promise(r => setTimeout(r, ms));
        }

        function updatePopPos() {
            if (!model) return;
            const pop = document.getElementById('emote-pop');
            if (pop.style.display === 'none') return;
            const pos = model.position.clone().add(new THREE.Vector3(0, 2, 0));
            pos.project(camera);
            const x = (pos.x * .5 + .5) * window.innerWidth;
            const y = (-(pos.y * .5) + .5) * window.innerHeight;
            pop.style.left = x + 'px';
            pop.style.top = y + 'px';
        }

        // ループ
        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(0.02);
            if (model && blobShadow) {
                blobShadow.position.set(model.position.x, 0.01, model.position.z);
            }
            if(isOpening) updatePopPos();
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
