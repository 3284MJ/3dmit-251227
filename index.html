<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Mitsuhashi Mobile Ready</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #debug-log {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            pointer-events: none; z-index: 1000; border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="debug-log">Status: Initializing...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const logElement = document.getElementById('debug-log');
        function debugLog(msg) { logElement.innerText = "Status: " + msg; }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // スマホの負荷軽減
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 2.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ visible: false }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let mixer, model, blobShadow, flag;
        let actions = {}; 
        let activeAction = null; 
        let targetPosition = null;
        let isProcessing = false;
        let isMoving = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // 影の作成
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0,0,0,0.6)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }
        blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, side: THREE.DoubleSide })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        blobShadow.position.y = 0.005;
        scene.add(blobShadow);

        // 旗の作成
        function createFlag() {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 0.5;
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
            cloth.position.set(0.2, 0.8, 0);
            group.add(pole, cloth);
            group.visible = false;
            scene.add(group);
            return group;
        }
        flag = createFlag();

        new GLTFLoader().load('./model.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip, index) => {
                actions[clip.name || `Motion ${index}`] = mixer.clipAction(clip);
            });
            debugLog("Ready! Tap ground to move.");
        });

        // 最短回転角度計算
        function getShortestAngle(targetAngle) {
            let diff = targetAngle - model.rotation.y;
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            return diff;
        }

        // スマホ・PC共通のクリック/タップハンドラ
        function handleInput(event) {
            if (!model || isProcessing || isMoving) return;

            let clientX, clientY;
            if (event.touches) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                targetPosition = intersects[0].point;
                flag.position.copy(targetPosition);
                flag.visible = true;
                processNavigation();
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });

        async function turnTowards(targetVec, isFinal = false) {
            const jumpAction = actions['垂直ジャンプ'] || Object.values(actions)[1];
            const runAction = actions['走行'] || Object.values(actions)[0];

            if (isFinal) {
                // 足踏み回転（走行モーション維持）
                await fadeTo(runAction, 0.2);
                while (true) {
                    const toTarget = new THREE.Vector3().subVectors(targetVec, model.position);
                    const diff = getShortestAngle(Math.atan2(toTarget.x, toTarget.z));
                    if (Math.abs(diff) < 0.05) break;
                    model.rotation.y += Math.sign(diff) * Math.min(Math.abs(diff), 0.06);
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                // ジャンプ回転
                while (true) {
                    const toTarget = new THREE.Vector3().subVectors(targetVec, model.position);
                    const diff = getShortestAngle(Math.atan2(toTarget.x, toTarget.z));
                    if (Math.abs(diff) < 0.1) break;

                    const step = Math.sign(diff) * Math.min(Math.abs(diff), THREE.MathUtils.degToRad(60));
                    await fadeTo(jumpAction, 0.1);
                    
                    const startRot = model.rotation.y;
                    const startTime = performance.now();
                    await new Promise(res => {
                        function r() {
                            const p = Math.min((performance.now() - startTime) / 800, 1);
                            model.rotation.y = startRot + step * p;
                            if (p < 1) requestAnimationFrame(r); else res();
                        }
                        r();
                    });
                    await new Promise(r => setTimeout(r, 100));
                }
            }
        }

        async function processNavigation() {
            isProcessing = true;
            
            // 1. 方向転換ジャンプ
            await turnTowards(targetPosition, false);
            
            // 2. 0.2秒停止
            if (activeAction) activeAction.fadeOut(0.2);
            activeAction = null;
            await new Promise(r => setTimeout(r, 200));

            // 3. 走行移動
            const runAction = actions['走行'] || Object.values(actions)[0];
            await fadeTo(runAction, 0.3);
            isMoving = true;
            
            await new Promise(resolve => {
                const check = setInterval(() => {
                    const dist = model.position.distanceTo(new THREE.Vector3(targetPosition.x, model.position.y, targetPosition.z));
                    if (dist <= 0.15) { clearInterval(check); resolve(); }
                }, 100);
            });
            isMoving = false;
            flag.visible = false;

            // 4. カメラ方向へ足踏み回転
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            await turnTowards(camPos, true);

            if (activeAction) activeAction.fadeOut(0.5);
            activeAction = null;
            isProcessing = false;
            debugLog("Goal!");
        }

        async function fadeTo(nextAction, duration) {
            if (!nextAction || activeAction === nextAction) return;
            if (activeAction) activeAction.fadeOut(duration);
            nextAction.reset().setEffectiveWeight(1).fadeIn(duration).play();
            activeAction = nextAction;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(1/60);

            if (isMoving && model && targetPosition) {
                const dir = new THREE.Vector3().subVectors(targetPosition, model.position).normalize();
                model.position.add(dir.setY(0).multiplyScalar(0.06));
            }

            if (model && blobShadow) {
                blobShadow.position.set(model.position.x, 0.005, model.position.z);
                blobShadow.material.opacity = Math.max(0, 1.0 - model.position.y * 0.4);
                const s = Math.max(0.1, 1.0 - model.position.y * 0.3);
                blobShadow.scale.set(s, s, 1);
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
