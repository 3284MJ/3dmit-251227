<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Mitsuhashi Manual</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0e0e0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UIÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ */
        .ui-panel {
            position: absolute; left: 10px;
            background: rgba(0,0,0,0.6); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            border-radius: 4px; z-index: 100;
            backdrop-filter: blur(2px);
            user-select: none;
        }

        #status-log { top: 10px; pointer-events: none; }

        #help-btn {
            top: 45px; cursor: pointer; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.3);
            display: flex; align-items: center; gap: 5px;
        }
        #help-btn::before { content: "‚ùì"; font-size: 14px; }

        /* --- „É¢„Éº„ÉÄ„É´Ôºà„Éò„É´„ÉóÔºâ --- */
        .modal-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 2000;
            justify-content: center; align-items: center;
        }
        .modal-card {
            background: white; width: 85%; max-width: 320px;
            padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; gap: 10px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .modal-header {
            font-size: 18px; font-weight: bold; color: #333;
            border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; margin-bottom: 5px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .help-list-item {
            background: #f8f9fa; padding: 12px; border-radius: 8px; cursor: pointer;
            font-weight: bold; color: #555; display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee;
        }
        .detail-view { display: none; text-align: left; }
        .detail-icon { font-size: 30px; text-align: center; margin: 15px 0; display: block; }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        .btn-close { background: #666; color: white; }

        /* --- „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ --- */
        #debug-panel {
            display: none;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85%; max-width: 350px;
            background: rgba(20, 20, 30, 0.95);
            color: #00ffcc;
            border: 1px solid #00ffcc;
            border-radius: 10px;
            padding: 20px;
            z-index: 3000;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
        }
        .debug-title {
            font-size: 16px; font-weight: bold; border-bottom: 1px dashed #00ffcc;
            margin-bottom: 15px; padding-bottom: 5px; text-align: center;
        }
        .debug-section { margin-bottom: 15px; }
        .debug-label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        .debug-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .debug-btn {
            flex: 1; background: #333; color: white; border: 1px solid #555;
            padding: 8px; border-radius: 4px; cursor: pointer; font-family: monospace;
        }
        .debug-btn:active { background: #555; }
        input[type=range] { width: 100%; accent-color: #00ffcc; }

        /* --- „Ç®„É¢„Éº„Ç∑„Éß„É≥„Éù„ÉÉ„ÉóÔºàÂêπ„ÅçÂá∫„ÅóÔºâ --- */
        #emote-pop {
            display: none;
            position: absolute;
            font-size: 40px;
            font-weight: bold;
            color: #ff4757;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            pointer-events: none;
            z-index: 500;
            animation: bounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom center;
        }
        @keyframes bounce {
            0% { transform: scale(0) translateY(20px); opacity: 0; }
            50% { transform: scale(1.2) translateY(-10px); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        /* --- „Ç¢„ÇØ„Ç∑„Éß„É≥„É°„Éã„É•„ÉºÔºà„Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´Áî®Ôºâ --- */
        #action-menu {
            display: none;
            position: absolute;
            /* „É¢„Éá„É´„ÅÆËøë„Åè„Å´Âá∫„Åô„Åü„ÇÅJS„ÅßÂà∂Âæ° */
            background: white;
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1500;
            animation: fadeIn 0.2s ease-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        .action-item {
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            text-align: center;
            white-space: nowrap;
        }
        .action-item:active { background: #2980b9; }
    </style>
</head>
<body>
    <div id="status-log" class="ui-panel">Status: Initializing...</div>
    <div id="help-btn" class="ui-panel" onclick="openHelpMenu()">Êìç‰ΩúË™¨Êòé</div>
    
    <div id="emote-pop">ÔºÅ</div>

    <div id="action-menu">
        <div class="action-item" onclick="onSoccerBallSelect()">„Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´</div>
    </div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <span id="modal-title">„É°„Éã„É•„Éº</span>
                <span style="cursor:pointer; font-size:20px;" onclick="closeModal()">√ó</span>
            </div>
            <div id="menu-list"></div>
            <div id="detail-area" class="detail-view">
                <div id="detail-content"></div>
                <div class="btn-group">
                    <button class="btn" style="background:#ddd" onclick="showList()">Êàª„Çã</button>
                    <button class="btn btn-close" onclick="closeModal()">Èñâ„Åò„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <div id="debug-panel">
        <div class="debug-title">DEBUG MENU</div>
        <div class="debug-section">
            <div class="debug-label">INITIALIZE</div>
            <div class="debug-row">
                <button class="debug-btn" onclick="resetCamera()">Reset Camera</button>
                <button class="debug-btn" onclick="resetModel()">Reset Model</button>
            </div>
        </div>
        <div class="debug-section">
            <div class="debug-label">PARAMETERS</div>
            <label>Walk Speed: <span id="val-walk">0.06</span></label>
            <input type="range" min="0.01" max="0.2" step="0.01" value="0.06" oninput="updateParam('walk', this.value)">
            <div style="height:10px"></div>
            <label>Dash Speed: <span id="val-dash">0.12</span></label>
            <input type="range" min="0.05" max="0.4" step="0.01" value="0.12" oninput="updateParam('dash', this.value)">
        </div>
        <button class="btn btn-close" style="width:100%" onclick="closeDebug()">CLOSE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script>
        window.params = { walkSpeed: 0.06, dashSpeed: 0.12 };

        // --- UI / „Éò„É´„ÉóÂà∂Âæ° ---
        const helpContent = [
            { title: "Ê≠©„ÅÑ„Å¶ÁßªÂãï", icon: "üëÜ", desc: "Âú∞Èù¢„Çí„Äê1Âõû„Çø„ÉÉ„Éó„Äë" },
            { title: "„ÉÄ„ÉÉ„Ç∑„É•ÁßªÂãï", icon: "üëÜüëÜ", desc: "Âú∞Èù¢„Çí„Äê2ÂõûÈÄ£Êâì„Äë" },
            { title: "„Ç¢„Ç§„Éâ„É™„É≥„Ç∞", icon: "ü§´", desc: "„Éü„ÉÑ„Éè„Ç∑„Åè„Çì„ÇíÊîæÁΩÆ„Åô„Çã„Å®ÈñãÂßã" },
            { title: "„Ç¢„Ç§„ÉÜ„É†„É°„Éã„É•„Éº", icon: "üéí", desc: "„Éü„ÉÑ„Éè„Ç∑„Åè„Çì„Çí„Äê„ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„Äë" },
            { title: "„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ", icon: "üîß", desc: "ÁîªÈù¢„ÅÆ„Å©„Åì„Åã„Çí„Äê3ÂõûÈÄ£Êâì„Äë" }
        ];

        window.isModalOpen = false;
        window.openHelpMenu = function() {
            window.isModalOpen = true;
            document.getElementById('help-modal').style.display = 'flex';
            showList();
        };
        window.closeModal = function() {
            window.isModalOpen = false;
            document.getElementById('help-modal').style.display = 'none';
        };
        window.showList = function() {
            const listEl = document.getElementById('menu-list');
            const detailEl = document.getElementById('detail-area');
            const titleEl = document.getElementById('modal-title');
            detailEl.style.display = 'none'; listEl.style.display = 'flex'; listEl.style.flexDirection = 'column'; listEl.style.gap = '8px';
            titleEl.innerText = 'Êìç‰ΩúË™¨Êòé„É°„Éã„É•„Éº';
            listEl.innerHTML = '';
            helpContent.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'help-list-item';
                div.innerHTML = `${item.title} <span>‚ñ∂</span>`;
                div.onclick = () => {
                    listEl.style.display = 'none';
                    detailEl.style.display = 'block';
                    titleEl.innerText = item.title;
                    document.getElementById('detail-content').innerHTML = `<span class="detail-icon">${item.icon}</span><div>${item.desc}</div>`;
                };
                listEl.appendChild(div);
            });
        };

        // „Éá„Éê„ÉÉ„Ç∞
        window.isDebugOpen = false;
        window.openDebug = function() {
            if (window.isModalOpen) return;
            window.isDebugOpen = true;
            document.getElementById('debug-panel').style.display = 'block';
        };
        window.closeDebug = function() {
            window.isDebugOpen = false;
            document.getElementById('debug-panel').style.display = 'none';
        };
        window.updateParam = function(key, val) {
            const num = parseFloat(val);
            if (key === 'walk') { window.params.walkSpeed = num; document.getElementById('val-walk').innerText = num.toFixed(2); }
            else if (key === 'dash') { window.params.dashSpeed = num; document.getElementById('val-dash').innerText = num.toFixed(2); }
        };

        // --- „Ç¢„ÇØ„Ç∑„Éß„É≥„É°„Éã„É•„ÉºÂà∂Âæ° ---
        window.closeActionMenu = function() {
            document.getElementById('action-menu').style.display = 'none';
        }
        // „Ç∞„É≠„Éº„Éê„É´Èñ¢Êï∞„Å®„Åó„Å¶ÂÆöÁæ©ÔºàHTML„Åã„ÇâÂëº„Å∂„Åü„ÇÅÔºâ
        window.onSoccerBallSelect = null; 
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const statusEl = document.getElementById('status-log');
        function debugLog(msg) { statusEl.innerText = "Status: " + msg; }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        scene.fog = new THREE.Fog(0xe0e0e0, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const DEFAULT_CAM_POS = new THREE.Vector3(0, 6, 12);
        camera.position.set(0, 5, 10); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(15, 64),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        let mixer, model, blobShadow, flag;
        let actions = {}; 
        let activeAction = null; 
        
        let idlingAction = null;
        let ballAction = null; // „Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´Âèñ„ÇäÂá∫„Åó„Ç¢„ÇØ„Ç∑„Éß„É≥
        let idleTimer = null;
        
        let soccerBallModel = null;
        let rightHandBone = null;

        let isProcessing = false; 
        let isMoving = false;     
        let isBoostMode = false;     
        let particles = [];
        let isOpening = true; 

        // ÂÖ•ÂäõÂà∂Âæ°
        let lastTapTime = 0;
        let tapStreak = 0;
        let tapResetTimer = null;
        let pointerDownPos = new THREE.Vector2();
        let isDragging = false;
        
        // „É¢„Éá„É´„ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØÁî®
        let modelTapCount = 0;
        let modelTapTimer = null;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.enabled = false;

        // --- „É™„Çª„ÉÉ„ÉàÈñ¢Êï∞ ---
        window.resetCamera = function() {
            if (isOpening) return;
            camera.position.copy(DEFAULT_CAM_POS);
            if (model) controls.target.copy(model.position).setY(0.5);
            else controls.target.set(0, 0, 0);
            controls.update();
            debugLog("Camera Reset.");
        };

        window.resetModel = function() {
            if (!model || isOpening) return;
            if (activeAction) activeAction.fadeOut(0.2);
            isMoving = false;
            isProcessing = false;
            model.position.set(0, 0, 0);
            model.rotation.set(0, 0, 0);
            const idle = actions['Motion 0'] || Object.values(actions)[0];
            if (idle) {
                idle.reset().play();
                activeAction = idle;
            }
            if (soccerBallModel) soccerBallModel.visible = false; // „Éú„Éº„É´„ÇÇÈö†„Åô
            controls.target.set(0, 0.5, 0);
            debugLog("Model Reset.");
        };

        // --- „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁîüÊàê ---
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(0,0,0,0.4)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, side: THREE.DoubleSide })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        blobShadow.position.y = 0.01;
        scene.add(blobShadow);

        function createFlag() {
            const g = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 0.5;
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
            cloth.position.set(0.2, 0.8, 0);
            cloth.castShadow = true;
            g.add(pole, cloth);
            g.visible = false;
            scene.add(g);
            return g;
        }
        flag = createFlag();

        function createSmoke(pos) {
            const m = new THREE.Mesh(
                new THREE.SphereGeometry(Math.random()*0.2+0.1, 5, 5),
                new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 })
            );
            m.position.copy(pos).add(new THREE.Vector3((Math.random()-.5)*0.3, 0.2, (Math.random()-.5)*0.3));
            scene.add(m);
            particles.push({ mesh: m, life: 1.0, vel: new THREE.Vector3(0, 0.03, 0) });
        }

        // --- GLTF„É≠„Éº„Éâ ---
        const loader = new GLTFLoader();
        
        loader.load('./model.glb', (gltf) => {
            model = gltf.scene;
            model.traverse(c => { 
                if(c.isMesh) c.castShadow = true; 
            });
            scene.add(model);
            
            // „Éú„Éº„É≥„ÇíÊé¢„Åó„Å¶‰øùÊåÅ„Åó„Å¶„Åä„ÅèÔºàÂè≥Êâã„ÅÆÈ™®Ôºâ
            // ‰∏ÄËà¨ÁöÑ„Å™Mixamo„É™„Ç∞„ÅÆÂêçÂâç: 'mixamorigRightHand' or 'RightHand'
            rightHandBone = model.getObjectByName('mixamorigRightHand') || model.getObjectByName('RightHand') || model.getObjectByName('Hand.R');
            if (!rightHandBone) {
                console.warn("Right hand bone not found! Logging all bone names:");
                model.traverse(o => { if(o.isBone) console.log(o.name); });
            }

            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip, i) => {
                actions[clip.name || `Motion${i}`] = mixer.clipAction(clip);
            });
            
            // „Ç¢„ÇØ„Ç∑„Éß„É≥Ââ≤„ÇäÂΩì„Å¶
            const actionValues = Object.values(actions);
            if (actionValues.length > 2) {
                idlingAction = actionValues[2];
                idlingAction.setLoop(THREE.LoopRepeat);
            }
            if (actionValues.length > 3) {
                ballAction = actionValues[3]; // 4Áï™ÁõÆ„ÅÆ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
                ballAction.setLoop(THREE.LoopOnce);
                ballAction.clampWhenFinished = true;
            }
            
            runOpeningSequence();
        });

        // „Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´„É≠„Éº„ÉâÔºàÈÅ∏ÊäûÊôÇ„Å´Âëº„Å∞„Çå„ÇãÔºâ
        function loadSoccerBall() {
            if (soccerBallModel) return; // Êó¢„Å´„É≠„Éº„ÉâÊ∏à„Åø
            loader.load('./soccer_ball.glb', (gltf) => {
                soccerBallModel = gltf.scene;
                soccerBallModel.scale.set(0.2, 0.2, 0.2); // „Çµ„Ç§„Ç∫Ë™øÊï¥
                soccerBallModel.traverse(c => { if(c.isMesh) c.castShadow = true; });
                
                // ÂàùÊúüÁä∂ÊÖã„ÅØÈùûË°®Á§∫
                soccerBallModel.visible = false;

                // Âè≥Êâã„ÅÆ„Éú„Éº„É≥„ÅåË¶ã„Å§„Åã„Å£„Å¶„ÅÑ„Çå„Å∞„Ç¢„Çø„ÉÉ„ÉÅ„ÄÅ„Å™„Åë„Çå„Å∞„Ç∑„Éº„É≥„Å´ËøΩÂä†
                if (rightHandBone) {
                    rightHandBone.add(soccerBallModel);
                    // Êâã„ÅÆ„Å≤„Çâ„Å´Âêà„ÅÜ„Çà„ÅÜ„Å´‰ΩçÁΩÆË™øÊï¥ÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Ë™øÊï¥„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ
                    soccerBallModel.position.set(0.1, 0.05, 0.05); 
                } else {
                    scene.add(soccerBallModel);
                }
            });
        }

        // --- „Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´ÈÅ∏ÊäûÊôÇ„ÅÆÂá¶ÁêÜ ---
        window.onSoccerBallSelect = async function() {
            window.closeActionMenu();
            if (isProcessing || isMoving) return;
            if (!ballAction) { debugLog("Animation 4 not found"); return; }
            
            isProcessing = true;
            resetIdleTimer();
            debugLog("Item: Soccer Ball");

            // 1. „Çµ„ÉÉ„Ç´„Éº„Éú„Éº„É´Ë™≠„ÅøËæº„ÅøÔºàÊú™„É≠„Éº„Éâ„Å™„ÇâÔºâ
            loadSoccerBall();

            // 2. „Ç´„É°„É©„ÅÆ„Åª„ÅÜ„ÇíÂêë„ÅèÔºàË∂≥Ë∏è„ÅøÂõûËª¢Ôºâ
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            await turnTowards(Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z), true);

            // 3. „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÜçÁîü
            await fadeTo(ballAction, 0.3);

            // 4. „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Å´Âêà„Çè„Åõ„Å¶„Éú„Éº„É´„ÇíË°®Á§∫„Åï„Åõ„ÇãÊºîÂá∫
            // ‚ÄªÊú¨Êù•„ÅØ„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Ç§„Éô„É≥„Éà„Çí‰Ωø„ÅÑ„Åæ„Åô„Åå„ÄÅÁ∞°ÊòìÁöÑ„Å´„Çø„Ç§„Éû„Éº„ÅßÂà∂Âæ°
            if (soccerBallModel) {
                soccerBallModel.visible = false;
                // ‰æã„Åà„Å∞ËÉå‰∏≠„Å´Êâã„ÇíÂõû„Åó„Åü„Çø„Ç§„Éü„É≥„Ç∞(0.5ÁßíÂæå„Å®„Åã)„ÅßË°®Á§∫
                setTimeout(() => {
                    if (activeAction === ballAction) soccerBallModel.visible = true;
                }, 800); 
            }

            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁµÇ‰∫ÜÂæÖ„Å°
            await new Promise(r => setTimeout(r, ballAction.getClip().duration * 1000));
            
            // ÁµÇ‰∫ÜÂæå„ÄÅÂ∞ë„ÅóÂæÖ„Å£„Å¶„Ç¢„Ç§„Éâ„É™„É≥„Ç∞„Å∏Êàª„ÇãÔºà„Éú„Éº„É´„ÅØÊåÅ„Å£„Åü„Åæ„ÅæÔºâ
            await new Promise(r => setTimeout(r, 1000));
            
            const idle = actions['Motion 0'] || Object.values(actions)[0];
            await fadeTo(idle, 0.5);
            
            isProcessing = false;
            resetIdleTimer();
        };

        // --- ‚òÖ„Ç™„Éº„Éó„Éã„É≥„Ç∞„Ç∑„Éº„Ç±„É≥„ÇπÔºà‰øÆÊ≠£ÁâàÔºâ ---
        async function runOpeningSequence() {
            debugLog("Opening: Initializing...");
            
            model.position.set(0, 0, -12);
            model.rotation.set(0, 0, 0);
            
            camera.position.set(0, 1.5, 4);
            controls.target.set(0, 0.8, -12);
            controls.update();

            // „Ç¢„Ç§„Éâ„É™„É≥„Ç∞Ôºà„Ç¢„Éã„É°3Ôºâ„Çí„É´„Éº„ÉóÂÜçÁîü
            let startAnim = actions['Motion 0'] || Object.values(actions)[0];
            if (idlingAction) startAnim = idlingAction;
            
            startAnim.reset().play();
            activeAction = startAnim;

            // 2ÁßíÂæÖÊ©ü
            debugLog("Opening: Wait 2s...");
            await new Promise(r => setTimeout(r, 2000));

            // „ÄåÔºÅ„ÄçË°®Á§∫
            const pop = document.getElementById('emote-pop');
            pop.style.display = 'block';
            updateEmotePosition(); 
            
            await new Promise(r => setTimeout(r, 500));
            pop.style.display = 'none';

            // ‚òÖËøΩÂä†Ôºö0.5ÁßíÂæÖÊ©ü
            await new Promise(r => setTimeout(r, 500));

            // Ëµ∞Ë°åÈñãÂßã
            debugLog("Opening: Running...");
            const run = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(run, 0.2);
            
            isMoving = true;
            const targetZ = -2.0;
            const runSpeed = 0.15;

            while (model.position.z < targetZ) {
                model.position.z += runSpeed;
                if (Math.random() > 0.7) {
                    createSmoke(model.position.clone().add(new THREE.Vector3(0,0,-0.5)));
                }
                controls.target.set(0, 0.8, model.position.z);
                controls.update();
                await new Promise(r => requestAnimationFrame(r));
            }

            isMoving = false;

            // ‚òÖ‰øÆÊ≠£ÔºöÁ¢∫ÂÆü„Å´ÂÅúÊ≠¢„Åï„Åõ„Çã
            // ÁèæÂú®„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÂÅúÊ≠¢„Åó„ÄÅÂç≥Â∫ß„Å´ÈÄöÂ∏∏ÂæÖÊ©ü„É¢„Éº„Ç∑„Éß„É≥„Å∏
            if (activeAction) activeAction.stop();
            const idle = actions['Motion 0'] || Object.values(actions)[0];
            idle.reset().play();
            activeAction = idle;
            
            // Âøµ„ÅÆ„Åü„ÇÅ„Éü„Ç≠„Çµ„ÉºÂÖ®‰Ωì„ÅÆÊôÇÈñì„ÇíÈÄ≤„ÇÅ„Å¶Êõ¥Êñ∞
            mixer.update(0);

            debugLog("Ready!");
            const startCamPos = camera.position.clone();
            const endCamPos = DEFAULT_CAM_POS.clone();
            const steps = 60;
            
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                const ease = 1 - Math.pow(1 - t, 3);
                camera.position.lerpVectors(startCamPos, endCamPos, ease);
                
                const currentTarget = controls.target.clone();
                const endTarget = new THREE.Vector3(0, 0.5, -2);
                controls.target.lerpVectors(currentTarget, endTarget, 0.1);
                
                controls.update();
                await new Promise(r => requestAnimationFrame(r));
            }

            isOpening = false;
            controls.enabled = true;
            resetIdleTimer();
        }

        function updateEmotePosition() {
            if (!model) return;
            const pop = document.getElementById('emote-pop');
            if (pop.style.display === 'none') return;
            const headPos = model.position.clone().add(new THREE.Vector3(-0.3, 2.0, 0));
            headPos.project(camera);
            const x = (headPos.x * .5 + .5) * window.innerWidth;
            const y = (-(headPos.y * .5) + .5) * window.innerHeight;
            pop.style.left = `${x}px`;
            pop.style.top = `${y}px`;
        }

        // --- ÂÖ•Âäõ„Ç§„Éô„É≥„Éà ---
        window.addEventListener('pointerdown', (e) => {
            if (isOpening) return;
            window.closeActionMenu(); // „É°„Éã„É•„Éº„ÇíÈñâ„Åò„Çã
            if (e.target.closest('.ui-panel') || e.target.closest('#debug-panel') || e.target.closest('#action-menu') || window.isModalOpen) return;
            isDragging = false;
            pointerDownPos.set(e.clientX, e.clientY);
        });

        window.addEventListener('pointermove', (e) => {
            if (new THREE.Vector2(e.clientX, e.clientY).distanceTo(pointerDownPos) > 10) {
                isDragging = true;
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (isOpening) return;
            if (e.target.closest('.ui-panel') || e.target.closest('#debug-panel') || e.target.closest('#action-menu') || window.isModalOpen) return;
            if (isDragging) return;

            // „Éà„É™„Éó„É´„Çø„ÉÉ„Éó(„Éá„Éê„ÉÉ„Ç∞)
            const now = Date.now();
            if (now - lastTapTime < 350) tapStreak++;
            else tapStreak = 1;
            lastTapTime = now;
            if (tapStreak === 3) { window.openDebug(); debugLog("Debug Mode Opened"); tapStreak = 0; return; }

            handleTapAction(e);
        });

        function handleTapAction(event) {
            if (!model || isProcessing) return;
            resetIdleTimer();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // „É¢„Éá„É´Âà§ÂÆö
            const intersectsModel = raycaster.intersectObject(model, true);
            if (intersectsModel.length > 0) {
                // ‚òÖ„ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÂà§ÂÆöÔºà„É¢„Éá„É´‰∏ä„ÅÆ„ÅøÔºâ
                if (modelTapTimer) {
                    clearTimeout(modelTapTimer);
                    modelTapTimer = null;
                    // Double Tap Action -> Show Menu
                    showActionMenu(event.clientX, event.clientY);
                } else {
                    modelTapTimer = setTimeout(() => {
                        modelTapTimer = null;
                        // Single Tap Action -> Play Idling
                        playIdlingAction("Tap on Model");
                    }, 250);
                }
                return;
            }

            // Âú∞Èù¢Âà§ÂÆö
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const point = intersects[0].point.clone();
                if (tapResetTimer) {
                    clearTimeout(tapResetTimer);
                    tapResetTimer = null;
                    startNavigation(point, true);
                } else {
                    tapResetTimer = setTimeout(() => {
                        tapResetTimer = null;
                        startNavigation(point, false);
                    }, 250);
                }
            }
        }

        // „Ç¢„ÇØ„Ç∑„Éß„É≥„É°„Éã„É•„ÉºË°®Á§∫
        function showActionMenu(x, y) {
            const menu = document.getElementById('action-menu');
            menu.style.display = 'block';
            menu.style.left = x + 'px';
            menu.style.top = (y - 50) + 'px'; // Â∞ë„Åó‰∏ä„Å´Ë°®Á§∫
            debugLog("Menu Opened");
        }

        function resetIdleTimer() {
            if (isOpening) return;
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(() => playIdlingAction("Idle Timeout"), 30000); 
        }

        async function playIdlingAction(source) {
            if (isProcessing || isMoving || !idlingAction) return;
            debugLog(`Idling: ${source}`);
            await fadeTo(idlingAction, 0.5);
        }

        async function startNavigation(targetPos, boost) {
            isProcessing = true;
            isBoostMode = boost;
            resetIdleTimer();
            flag.position.copy(targetPos);
            flag.children[1].material.color.set(isBoostMode ? 0xffd700 : 0xff4757); 
            flag.visible = true;
            debugLog(isBoostMode ? "Dash!" : "Walking...");
            const toTarget = new THREE.Vector3().subVectors(targetPos, model.position);
            await turnTowards(Math.atan2(toTarget.x, toTarget.z), false);
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(runAction, 0.2);
            isMoving = true;
            const speed = isBoostMode ? window.params.dashSpeed : window.params.walkSpeed;
            const stopDist = isBoostMode ? 0.8 : 0.1;
            await new Promise(resolve => {
                const interval = setInterval(() => {
                    resetIdleTimer();
                    const dist = model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z));
                    if (dist > 0.05) {
                        const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                        model.position.add(dir.setY(0).multiplyScalar(speed));
                        if (isBoostMode && Math.random() > 0.3) createSmoke(model.position.clone().add(dir.multiplyScalar(-0.4)));
                    }
                    if (dist <= stopDist) { clearInterval(interval); resolve(); }
                }, 16);
            });
            if (isBoostMode) {
                for(let i=0; i<15; i++) { model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(speed * 0.5)); await new Promise(r => requestAnimationFrame(r)); }
                isMoving = false;
                await new Promise(r => setTimeout(r, 100));
                while (model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z)) > 0.1) {
                    model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(0.03));
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                isMoving = false;
            }
            flag.visible = false;
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            await turnTowards(Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z), true);
            if (activeAction) activeAction.fadeOut(0.5);
            activeAction = null;
            isProcessing = false;
            resetIdleTimer();
            debugLog("Ready.");
        }

        async function turnTowards(targetAngle, isStepping) {
            const jumpAction = actions['ÂûÇÁõ¥„Ç∏„É£„É≥„Éó'] || Object.values(actions)[1];
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            if (isStepping) {
                await fadeTo(runAction, 0.2);
                while (true) {
                    let diff = targetAngle - model.rotation.y;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.05) break;
                    model.rotation.y += Math.sign(diff) * 0.08;
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                let diff = targetAngle - model.rotation.y;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                if (Math.abs(diff) > 0.3) {
                    await fadeTo(jumpAction, 0.1);
                    const startRot = model.rotation.y;
                    const steps = 30;
                    for (let i = 0; i <= steps; i++) {
                        model.rotation.y = startRot + (diff * (i/steps));
                        await new Promise(r => requestAnimationFrame(r));
                    }
                    await new Promise(r => setTimeout(r, 50));
                } else {
                    model.rotation.y = targetAngle;
                }
            }
        }

        async function fadeTo(next, dur) {
            if (!next || activeAction === next) return;
            if (activeAction) activeAction.fadeOut(dur);
            next.reset().setEffectiveWeight(1).fadeIn(dur).play();
            activeAction = next;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(1/60);
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                p.mesh.position.add(p.vel);
                p.mesh.scale.multiplyScalar(1.03);
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
            if (model) {
                if (blobShadow) {
                    blobShadow.position.set(model.position.x, 0.01, model.position.z);
                    const s = Math.max(0.1, 1.0 - model.position.y * 0.5);
                    blobShadow.scale.set(s, s, 1);
                    blobShadow.material.opacity = s * 0.6;
                }
                updateEmotePosition();
                if (!isOpening && !isDragging) {
                    const targetPos = model.position.clone().setY(0.5);
                    controls.target.lerp(targetPos, 0.1);
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
