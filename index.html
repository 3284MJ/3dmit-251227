<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mitsuhashi-kun v1.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f8ff; font-family: 'Courier New', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none; /* クリックを通過させる */
        }
        .panel {
            background: rgba(0, 0, 0, 0.6);
            color: #00ff00;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            max-width: 300px;
            backdrop-filter: blur(2px);
        }
        h1 { margin: 0 0 5px 0; font-size: 16px; border-bottom: 1px solid #00ff00; }
        p, li { font-size: 12px; margin: 2px 0; }
        ul { padding-left: 20px; margin: 5px 0; }
        
        /* Log Area */
        #log-area {
            height: 100px;
            overflow-y: auto;
            font-size: 10px;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="panel">
            <h1>MITSUHASHI OS v1.0</h1>
            <p>Status: <span id="status-text">IDLE</span></p>
            <p>Speed: <span id="speed-text">0</span></p>
        </div>
        <div class="panel">
            <h1>CONTROLS</h1>
            <ul>
                <li>Tap: Move (Walk)</li>
                <li>Double Tap: BOOST (Run & Slide)</li>
            </ul>
        </div>
        <div class="panel" id="log-area">
            > System Ready...<br>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const CONFIG = {
            colorBody: 0xffcc00, // ミツハシ・イエロー
            colorLimb: 0x333333,
            walkSpeed: 0.05,
            boostSpeed: 0.25,
            friction: 0.92, // 減速率
            overrunDist: 2.0 // ブースト時に行き過ぎる距離
        };

        // --- Global Variables ---
        let scene, camera, renderer, raycaster;
        let mitsuhashiGroup;
        let targetPosition = new THREE.Vector3();
        let isMoving = false;
        let velocity = new THREE.Vector3();
        
        // Input Handling
        let lastTapTime = 0;
        const doubleTapDelay = 300; // ms
        
        // Particles
        let particles = [];

        // UI
        const statusEl = document.getElementById('status-text');
        const speedEl = document.getElementById('speed-text');
        const logEl = document.getElementById('log-area');

        function log(msg) {
            logEl.innerHTML += `> ${msg}<br>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0e0e0);
            scene.fog = new THREE.Fog(0xe0e0e0, 10, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 10, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // Ground
            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            // Grid Helper
            const gridHelper = new THREE.GridHelper(100, 100, 0x000000, 0xaaaaaa);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // Create Mitsuhashi
            createMitsuhashi();

            // Raycaster
            raycaster = new THREE.Raycaster();

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);

            log("Mitsuhashi-kun Initialized.");
            animate();
        }

        function createMitsuhashi() {
            mitsuhashiGroup = new THREE.Group();

            // Body (Sphere)
            const bodyGeo = new THREE.SphereGeometry(0.8, 32, 32);
            const bodyMat = new THREE.MeshStandardMaterial({ color: CONFIG.colorBody, roughness: 0.4 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;
            mitsuhashiGroup.add(body);

            // Eyes (Simple boxes)
            const eyeGeo = new THREE.BoxGeometry(0.15, 0.15, 0.1);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.3, 1.0, 0.7);
            mitsuhashiGroup.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.3, 1.0, 0.7);
            mitsuhashiGroup.add(rightEye);

            // Limbs (Small spheres)
            const limbGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const limbMat = new THREE.MeshStandardMaterial({ color: CONFIG.colorLimb });

            // Hands
            const handL = new THREE.Mesh(limbGeo, limbMat);
            handL.position.set(-0.9, 0.8, 0);
            mitsuhashiGroup.add(handL);
            
            const handR = new THREE.Mesh(limbGeo, limbMat);
            handR.position.set(0.9, 0.8, 0);
            mitsuhashiGroup.add(handR);

            // Feet
            const footL = new THREE.Mesh(limbGeo, limbMat);
            footL.position.set(-0.4, 0.25, 0);
            mitsuhashiGroup.add(footL);

            const footR = new THREE.Mesh(limbGeo, limbMat);
            footR.position.set(0.4, 0.25, 0);
            mitsuhashiGroup.add(footR);

            scene.add(mitsuhashiGroup);
        }

        // --- Logic: Movement & Interaction ---

        function onPointerDown(event) {
            // Screen coordinates to Normalized Device Coordinates (-1 to +1)
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            for (let i = 0; i < intersects.length; i++) {
                // Ignore Mitsuhashi himself to allow clicking ground "behind" him
                if (intersects[i].object.uuid !== mitsuhashiGroup.uuid) {
                    const point = intersects[i].point;
                    handleInput(point);
                    break;
                }
            }
        }

        // State variables for animation logic
        let moveState = 'IDLE'; // IDLE, WALK, BOOST_ACCEL, BOOST_BRAKE, RECOVER
        let boostTarget = new THREE.Vector3(); // The actual click point
        let overshootTarget = new THREE.Vector3(); // The point he slips to

        function handleInput(point) {
            const now = Date.now();
            const timeDiff = now - lastTapTime;
            
            // Ground level fix
            point.y = 0;
            
            if (timeDiff < doubleTapDelay) {
                // === DOUBLE TAP (BOOST) ===
                log(">> BOOST MODE ACTIVATED!");
                statusEl.innerText = "BOOST!!";
                moveState = 'BOOST_ACCEL';
                
                // Calculate direction
                const direction = new THREE.Vector3().subVectors(point, mitsuhashiGroup.position).normalize();
                
                // Set targets
                boostTarget.copy(point);
                overshootTarget.copy(point).add(direction.multiplyScalar(CONFIG.overrunDist)); // Go past target
                
                targetPosition.copy(overshootTarget); // Aim for overshoot first

            } else {
                // === SINGLE TAP (WALK) ===
                log("Target set.");
                statusEl.innerText = "WALKING";
                moveState = 'WALK';
                targetPosition.copy(point);
            }
            
            isMoving = true;
            lastTapTime = now;
        }

        function createSmoke(position) {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.copy(position);
            mesh.position.y = 0.5; // ground level
            
            // Random spread
            mesh.position.x += (Math.random() - 0.5) * 0.5;
            mesh.position.z += (Math.random() - 0.5) * 0.5;

            scene.add(mesh);
            particles.push({ mesh: mesh, life: 1.0, velocity: new THREE.Vector3(0, 0.05, 0) });
        }

        function updateMitsuhashi() {
            if (!isMoving) return;

            const currentPos = mitsuhashiGroup.position.clone();
            const distToTarget = currentPos.distanceTo(targetPosition);
            
            // Look at target
            mitsuhashiGroup.lookAt(targetPosition.x, mitsuhashiGroup.position.y, targetPosition.z);

            // Determine speed based on state
            let speed = 0;

            if (moveState === 'WALK') {
                speed = CONFIG.walkSpeed;
                if (distToTarget < 0.1) {
                    isMoving = false;
                    moveState = 'IDLE';
                    statusEl.innerText = "IDLE";
                }
            } 
            else if (moveState === 'BOOST_ACCEL') {
                speed = CONFIG.boostSpeed;
                createSmoke(currentPos); // Smoke while boosting

                // If close to the overshoot target, switch to braking/recovering
                if (distToTarget < 0.5) {
                    moveState = 'RECOVER';
                    log(">> Oops! Too far! (Backing up...)");
                    statusEl.innerText = "RECOVERING";
                    // Change target back to original click point
                    targetPosition.copy(boostTarget);
                }
            }
            else if (moveState === 'RECOVER') {
                speed = CONFIG.walkSpeed * 0.5; // Walk back slowly (shamefully)
                if (distToTarget < 0.1) {
                    isMoving = false;
                    moveState = 'IDLE';
                    statusEl.innerText = "IDLE";
                }
            }

            // Apply movement
            if (isMoving) {
                const dir = new THREE.Vector3().subVectors(targetPosition, currentPos).normalize();
                velocity.copy(dir).multiplyScalar(speed);
                mitsuhashiGroup.position.add(velocity);
                
                // Bouncing animation (Visual only)
                const time = Date.now() * 0.005;
                if(moveState === 'BOOST_ACCEL') {
                    mitsuhashiGroup.position.y = 0.8; // Slide flat
                    mitsuhashiGroup.rotation.z = Math.sin(time * 10) * 0.1; // Shake
                } else {
                    mitsuhashiGroup.position.y = 0.8 + Math.abs(Math.sin(time * 2)) * 0.2; // Hop
                    mitsuhashiGroup.rotation.z = 0;
                }
            }

            // Update Speed UI
            speedEl.innerText = velocity.length().toFixed(3);
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                p.mesh.position.add(p.velocity);
                p.mesh.scale.multiplyScalar(0.95); // Shrink
                p.mesh.material.opacity = p.life;

                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMitsuhashi();
            updateParticles();
            renderer.render(scene, camera);
        }

        // Start
        init();
    </script>
</body>
</html>
