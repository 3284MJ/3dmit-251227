<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mitsuhashi-kun V1.2.0 - Intro Dash (Fixed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f8ff; font-family: 'Segoe UI', sans-serif; }
        
        /* UI: ログエリア (V1.1.0準拠) */
        #log-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            background: rgba(0, 0, 0, 0.6);
            color: #00ffcc;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }

        /* UI: 操作説明モーダル (V1.1.0準拠) */
        #help-modal {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
            max-width: 250px;
            font-size: 13px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            z-index: 10;
        }
        h3 { margin: 0 0 8px 0; color: #ffd700; border-bottom: 1px solid #555; padding-bottom: 5px; }
        ul { padding-left: 20px; margin: 0; }
        li { margin-bottom: 4px; }
        .highlight { color: #ffd700; font-weight: bold; }
    </style>
</head>
<body>

    <div id="log-container">
        <div><strong>MITSUHASHI_SYS_LOG v1.2.0</strong></div>
        <div id="status">Status: IDLE</div>
        <div id="coords">Pos: (0.0, 0.0)</div>
    </div>

    <div id="help-modal">
        <h3>Mitsuhashi Controls</h3>
        <ul>
            <li><span class="highlight">Start:</span> ダッシュで登場</li>
            <li><span class="highlight">1 Tap:</span> トコトコ移動</li>
            <li><span class="highlight">2 Taps:</span> BOOST (急加速+バック)</li>
        </ul>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration (V1.1.0 Base) ---
        const SETTINGS = {
            moveSpeed: 0.1,
            boostSpeed: 0.3,
            introSpeed: 0.6,      // 登場時の速度
            colors: {
                body: 0xffd700,   // ミツハシイエロー
                eye: 0x111111,
                cheek: 0xffa07a,
                limb: 0xffcc00    // 手足の色
            }
        };

        // --- Global Variables ---
        let scene, camera, renderer;
        let mitsuhashi; 
        let targetPosition = new THREE.Vector3();
        let isMoving = false;
        let isBoosting = false;
        
        // V1.2.0 New Flag
        let isIntro = true; 

        // Raycaster
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let lastTapTime = 0;

        // Effects
        const particles = [];

        // UI
        const elStatus = document.getElementById('status');
        const elCoords = document.getElementById('coords');

        init();
        animate();

        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f8ff); // AliceBlue
            scene.fog = new THREE.Fog(0xf0f8ff, 20, 80);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            // カメラ位置：少し引き気味で、正面からの登場が見える位置
            camera.position.set(0, 10, 20); 
            camera.lookAt(0, 0, 0);

            // 3. Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 4. Ground (Invisible for Raycasting)
            // グリッド等は排除し、純粋なRaycast用のみ配置
            const planeGeo = new THREE.PlaneGeometry(500, 500);
            const planeMat = new THREE.MeshBasicMaterial({ visible: false }); 
            const floor = new THREE.Mesh(planeGeo, planeMat);
            floor.rotation.x = -Math.PI / 2;
            floor.name = "floor";
            scene.add(floor);

            // 5. Character (Restoring Mitsuhashi Design)
            createMitsuhashi();

            // --- V1.2.0 Intro Setup ---
            // 画面奥(-60)からスタート
            mitsuhashi.position.set(0, 0, -60);
            targetPosition.set(0, 0, 0); // 目標は原点
            
            // 6. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 7. Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
        }

        function createMitsuhashi() {
            mitsuhashi = new THREE.Group();

            // Body (丸いフォルム)
            const bodyGeo = new THREE.SphereGeometry(1, 32, 32);
            const bodyMat = new THREE.MeshStandardMaterial({ color: SETTINGS.colors.body });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1;
            body.castShadow = true;
            mitsuhashi.add(body);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshBasicMaterial({ color: SETTINGS.colors.eye });
            
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.35, 1.2, 0.85);
            mitsuhashi.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.35, 1.2, 0.85);
            mitsuhashi.add(rightEye);

            // Cheeks
            const cheekGeo = new THREE.CircleGeometry(0.15, 16);
            const cheekMat = new THREE.MeshBasicMaterial({ color: SETTINGS.colors.cheek });
            
            const leftCheek = new THREE.Mesh(cheekGeo, cheekMat);
            leftCheek.position.set(-0.6, 1.1, 0.8);
            leftCheek.rotation.y = -0.5;
            mitsuhashi.add(leftCheek);

            const rightCheek = new THREE.Mesh(cheekGeo, cheekMat);
            rightCheek.position.set(0.6, 1.1, 0.8);
            rightCheek.rotation.y = 0.5;
            mitsuhashi.add(rightCheek);

            // Limbs (Short Hands/Feet to complete the look)
            const limbGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const limbMat = new THREE.MeshStandardMaterial({ color: SETTINGS.colors.limb });

            // Feet
            const leftFoot = new THREE.Mesh(limbGeo, limbMat);
            leftFoot.position.set(-0.4, 0.2, 0); // 体の下に隠れるように
            leftFoot.scale.set(1, 0.6, 1.5);
            mitsuhashi.add(leftFoot);

            const rightFoot = new THREE.Mesh(limbGeo, limbMat);
            rightFoot.position.set(0.4, 0.2, 0);
            rightFoot.scale.set(1, 0.6, 1.5);
            mitsuhashi.add(rightFoot);

            // Hands (Tiny, side)
            const leftHand = new THREE.Mesh(limbGeo, limbMat);
            leftHand.position.set(-0.9, 0.8, 0);
            mitsuhashi.add(leftHand);

            const rightHand = new THREE.Mesh(limbGeo, limbMat);
            rightHand.position.set(0.9, 0.8, 0);
            mitsuhashi.add(rightHand);

            // Shadow
            const shadowGeo = new THREE.CircleGeometry(0.8, 32);
            const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.2 });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.rotation.x = -Math.PI / 2;
            shadow.position.y = 0.02;
            mitsuhashi.add(shadow);

            scene.add(mitsuhashi);
        }

        function onPointerDown(event) {
            // イントロ中は操作させない
            if (isIntro) return;

            event.preventDefault();
            
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(scene.children);
            const floorHit = intersects.find(hit => hit.object.name === "floor");

            if (floorHit) {
                const now = Date.now();
                if (now - lastTapTime < 300) {
                    // Double Tap
                    isBoosting = true;
                    isMoving = true;
                    
                    // オーバーラン計算
                    const dir = new THREE.Vector3().subVectors(floorHit.point, mitsuhashi.position).normalize();
                    targetPosition.copy(floorHit.point).add(dir.multiplyScalar(4)); // 4m行き過ぎる

                    elStatus.textContent = "Status: BOOST!!";
                } else {
                    // Single Tap
                    isBoosting = false;
                    isMoving = true;
                    targetPosition.copy(floorHit.point);
                    elStatus.textContent = "Status: WALKING";
                }
                lastTapTime = now;
            }
        }

        function spawnSmoke() {
            const geo = new THREE.CircleGeometry(0.3, 8);
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.5, 
                side: THREE.DoubleSide 
            });
            const mesh = new THREE.Mesh(geo, mat);
            
            mesh.position.copy(mitsuhashi.position);
            mesh.position.y = 0.2;
            mesh.lookAt(camera.position); // ビルボード処理

            scene.add(mesh);
            particles.push({ mesh, life: 1.0 });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.05;
                p.mesh.position.y += 0.05;
                p.mesh.scale.multiplyScalar(0.95);
                p.mesh.material.opacity = p.life;
                
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // --- Intro Sequence ---
            if (isIntro) {
                // 原点(0,0,0)に向かって走る
                const dist = mitsuhashi.position.distanceTo(new THREE.Vector3(0,0,0));
                
                if (dist > 1.0) {
                    // 移動
                    mitsuhashi.position.z += SETTINGS.introSpeed;
                    
                    // 必死に走るアニメーション (左右の揺れを大きく)
                    mitsuhashi.rotation.z = Math.sin(Date.now() * 0.02) * 0.15;
                    mitsuhashi.position.y = 1 + Math.abs(Math.sin(Date.now() * 0.02)) * 0.3;
                    
                    // 煙
                    if(Math.random() > 0.7) spawnSmoke();

                    elStatus.textContent = "Status: INTRO DASH";
                } else {
                    // 到着
                    isIntro = false;
                    mitsuhashi.position.set(0, 1, 0);
                    mitsuhashi.rotation.set(0, 0, 0);
                    elStatus.textContent = "Status: READY";
                }
            } 
            // --- Normal Logic ---
            else if (isMoving) {
                const dist = mitsuhashi.position.distanceTo(targetPosition);
                const threshold = isBoosting ? 0.5 : 0.1;

                if (dist > threshold) {
                    const dir = new THREE.Vector3().subVectors(targetPosition, mitsuhashi.position).normalize();
                    const spd = isBoosting ? SETTINGS.boostSpeed : SETTINGS.moveSpeed;

                    mitsuhashi.position.add(dir.multiplyScalar(spd));
                    mitsuhashi.lookAt(targetPosition.x, 1, targetPosition.z);

                    // 跳ねるアニメーション
                    const freq = isBoosting ? 0.03 : 0.015;
                    mitsuhashi.position.y = 1 + Math.abs(Math.sin(Date.now() * freq)) * 0.3;

                    if (isBoosting) spawnSmoke();
                } else {
                    isMoving = false;
                    isBoosting = false;
                    mitsuhashi.position.y = 1;
                    elStatus.textContent = "Status: IDLE";
                }
            }

            updateParticles();
            elCoords.textContent = `Pos: (${mitsuhashi.position.x.toFixed(1)}, ${mitsuhashi.position.z.toFixed(1)})`;

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
