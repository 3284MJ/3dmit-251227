<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Mitsuhashi Manual</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0e0e0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UIÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ */
        .ui-panel {
            position: absolute; left: 10px;
            background: rgba(0,0,0,0.6); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            border-radius: 4px; z-index: 100;
            backdrop-filter: blur(2px);
            user-select: none;
        }

        #status-log { top: 10px; pointer-events: none; }

        #help-btn {
            top: 45px; cursor: pointer; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.3);
            display: flex; align-items: center; gap: 5px;
        }
        #help-btn::before { content: "‚ùì"; font-size: 14px; }

        /* --- „É¢„Éº„ÉÄ„É´Ôºà„Éò„É´„ÉóÔºâ --- */
        .modal-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 2000;
            justify-content: center; align-items: center;
        }
        .modal-card {
            background: white; width: 85%; max-width: 320px;
            padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; gap: 10px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .modal-header {
            font-size: 18px; font-weight: bold; color: #333;
            border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; margin-bottom: 5px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .help-list-item {
            background: #f8f9fa; padding: 12px; border-radius: 8px; cursor: pointer;
            font-weight: bold; color: #555; display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee;
        }
        .detail-view { display: none; text-align: left; }
        .detail-icon { font-size: 30px; text-align: center; margin: 15px 0; display: block; }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        .btn-close { background: #666; color: white; }

        /* --- „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ --- */
        #debug-panel {
            display: none;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 85%; max-width: 350px;
            background: rgba(20, 20, 30, 0.95);
            color: #00ffcc;
            border: 1px solid #00ffcc;
            border-radius: 10px;
            padding: 20px;
            z-index: 3000;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
        }
        .debug-title {
            font-size: 16px; font-weight: bold; border-bottom: 1px dashed #00ffcc;
            margin-bottom: 15px; padding-bottom: 5px; text-align: center;
        }
        .debug-section { margin-bottom: 15px; }
        .debug-label { display: block; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        .debug-row { display: flex; gap: 10px; margin-bottom: 10px; }
        .debug-btn {
            flex: 1; background: #333; color: white; border: 1px solid #555;
            padding: 8px; border-radius: 4px; cursor: pointer; font-family: monospace;
        }
        .debug-btn:active { background: #555; }
        input[type=range] { width: 100%; accent-color: #00ffcc; }

        /* --- „Ç®„É¢„Éº„Ç∑„Éß„É≥„Éù„ÉÉ„ÉóÔºàÂêπ„ÅçÂá∫„ÅóÔºâ --- */
        #emote-pop {
            display: none;
            position: absolute;
            font-size: 40px;
            font-weight: bold;
            color: #ff4757;
            text-shadow: 2px 2px 0px white, -2px -2px 0px white, 2px -2px 0px white, -2px 2px 0px white;
            pointer-events: none;
            z-index: 500;
            animation: bounce 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform-origin: bottom center;
        }
        @keyframes bounce {
            0% { transform: scale(0) translateY(20px); opacity: 0; }
            50% { transform: scale(1.2) translateY(-10px); opacity: 1; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="status-log" class="ui-panel">Status: Initializing...</div>
    <div id="help-btn" class="ui-panel" onclick="openHelpMenu()">Êìç‰ΩúË™¨Êòé</div>
    
    <div id="emote-pop">ÔºÅ</div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <span id="modal-title">„É°„Éã„É•„Éº</span>
                <span style="cursor:pointer; font-size:20px;" onclick="closeModal()">√ó</span>
            </div>
            <div id="menu-list"></div>
            <div id="detail-area" class="detail-view">
                <div id="detail-content"></div>
                <div class="btn-group">
                    <button class="btn" style="background:#ddd" onclick="showList()">Êàª„Çã</button>
                    <button class="btn btn-close" onclick="closeModal()">Èñâ„Åò„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <div id="debug-panel">
        <div class="debug-title">DEBUG MENU</div>
        
        <div class="debug-section">
            <div class="debug-label">INITIALIZE</div>
            <div class="debug-row">
                <button class="debug-btn" onclick="resetCamera()">Reset Camera</button>
                <button class="debug-btn" onclick="resetModel()">Reset Model</button>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-label">PARAMETERS</div>
            <label>Walk Speed: <span id="val-walk">0.06</span></label>
            <input type="range" min="0.01" max="0.2" step="0.01" value="0.06" oninput="updateParam('walk', this.value)">
            
            <div style="height:10px"></div>

            <label>Dash Speed: <span id="val-dash">0.12</span></label>
            <input type="range" min="0.05" max="0.4" step="0.01" value="0.12" oninput="updateParam('dash', this.value)">
        </div>

        <button class="btn btn-close" style="width:100%" onclick="closeDebug()">CLOSE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script>
        // --- Ë®≠ÂÆö„Éë„É©„É°„Éº„Çø ---
        window.params = {
            walkSpeed: 0.06,
            dashSpeed: 0.12
        };

        // --- UI / „Éò„É´„ÉóÂà∂Âæ° ---
        const helpContent = [
            { title: "Ê≠©„ÅÑ„Å¶ÁßªÂãï", icon: "üëÜ", desc: "Âú∞Èù¢„Çí„Äê1Âõû„Çø„ÉÉ„Éó„Äë" },
            { title: "„ÉÄ„ÉÉ„Ç∑„É•ÁßªÂãï", icon: "üëÜüëÜ", desc: "Âú∞Èù¢„Çí„Äê2ÂõûÈÄ£Êâì„Äë" },
            { title: "„Å≤„Åø„Å§„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥", icon: "ü§´", desc: "„Éü„ÉÑ„Éè„Ç∑„Åè„Çì„Çí„Çø„ÉÉ„Éó„ÄÅ„Åæ„Åü„ÅØÊîæÁΩÆ" },
            { title: "„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ", icon: "üîß", desc: "ÁîªÈù¢„ÅÆ„Å©„Åì„Åã„Çí„Äê3ÂõûÈÄ£Êâì„Äë" }
        ];

        window.isModalOpen = false;
        window.openHelpMenu = function() {
            window.isModalOpen = true;
            document.getElementById('help-modal').style.display = 'flex';
            showList();
        };
        window.closeModal = function() {
            window.isModalOpen = false;
            document.getElementById('help-modal').style.display = 'none';
        };
        window.showList = function() {
            const listEl = document.getElementById('menu-list');
            const detailEl = document.getElementById('detail-area');
            const titleEl = document.getElementById('modal-title');
            detailEl.style.display = 'none'; listEl.style.display = 'flex'; listEl.style.flexDirection = 'column'; listEl.style.gap = '8px';
            titleEl.innerText = 'Êìç‰ΩúË™¨Êòé„É°„Éã„É•„Éº';
            listEl.innerHTML = '';
            helpContent.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'help-list-item';
                div.innerHTML = `${item.title} <span>‚ñ∂</span>`;
                div.onclick = () => {
                    listEl.style.display = 'none';
                    detailEl.style.display = 'block';
                    titleEl.innerText = item.title;
                    document.getElementById('detail-content').innerHTML = `<span class="detail-icon">${item.icon}</span><div>${item.desc}</div>`;
                };
                listEl.appendChild(div);
            });
        };

        // --- „Éá„Éê„ÉÉ„Ç∞Âà∂Âæ° ---
        window.isDebugOpen = false;
        window.openDebug = function() {
            if (window.isModalOpen) return;
            window.isDebugOpen = true;
            document.getElementById('debug-panel').style.display = 'block';
        };
        window.closeDebug = function() {
            window.isDebugOpen = false;
            document.getElementById('debug-panel').style.display = 'none';
        };
        window.updateParam = function(key, val) {
            const num = parseFloat(val);
            if (key === 'walk') {
                window.params.walkSpeed = num;
                document.getElementById('val-walk').innerText = num.toFixed(2);
            } else if (key === 'dash') {
                window.params.dashSpeed = num;
                document.getElementById('val-dash').innerText = num.toFixed(2);
            }
        };
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const statusEl = document.getElementById('status-log');
        function debugLog(msg) { statusEl.innerText = "Status: " + msg; }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0);
        scene.fog = new THREE.Fog(0xe0e0e0, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // ÈÄöÂ∏∏ÊôÇ„ÅÆ„Ç´„É°„É©‰ΩçÁΩÆ
        const DEFAULT_CAM_POS = new THREE.Vector3(0, 6, 12);
        
        // „Ç™„Éº„Éó„Éã„É≥„Ç∞ÊôÇ„ÅÆÂàùÊúüË®≠ÂÆö„ÅØ„É≠„Éº„ÉâÂÆå‰∫ÜÂæå„Å´ÈÅ©Áî®
        camera.position.set(0, 5, 10); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // „Éï„Ç£„Éº„É´„Éâ
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(15, 64),
            new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.4, side: THREE.DoubleSide })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        let mixer, model, blobShadow, flag;
        let actions = {}; 
        let activeAction = null; 
        let specialAction = null;
        let idleTimer = null;
        
        let isProcessing = false; 
        let isMoving = false;     
        let isBoostMode = false;     
        let particles = [];
        let isOpening = true; // „Ç™„Éº„Éó„Éã„É≥„Ç∞‰∏≠„Éï„É©„Ç∞      

        // ÂÖ•ÂäõÂà∂Âæ°
        let lastTapTime = 0;
        let tapStreak = 0;
        let tapResetTimer = null;
        let pointerDownPos = new THREE.Vector2();
        let isDragging = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.enabled = false; // „Ç™„Éº„Éó„Éã„É≥„Ç∞‰∏≠„ÅØÁÑ°ÂäπÂåñ

        // --- „É™„Çª„ÉÉ„ÉàÈñ¢Êï∞ ---
        window.resetCamera = function() {
            if (isOpening) return;
            camera.position.copy(DEFAULT_CAM_POS);
            if (model) {
                controls.target.copy(model.position).setY(0.5);
            } else {
                controls.target.set(0, 0, 0);
            }
            controls.update();
            debugLog("Camera Reset.");
        };

        window.resetModel = function() {
            if (!model || isOpening) return;
            if (activeAction) activeAction.fadeOut(0.2);
            isMoving = false;
            isProcessing = false;
            
            model.position.set(0, 0, 0);
            model.rotation.set(0, 0, 0);
            
            const idle = actions['Motion 0'] || Object.values(actions)[0];
            if (idle) {
                idle.reset().play();
                activeAction = idle;
            }
            controls.target.set(0, 0.5, 0);
            debugLog("Model Reset.");
        };

        // --- „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÁîüÊàê ---
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(0,0,0,0.4)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, side: THREE.DoubleSide })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        blobShadow.position.y = 0.01;
        scene.add(blobShadow);

        function createFlag() {
            const g = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 0.5;
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
            cloth.position.set(0.2, 0.8, 0);
            cloth.castShadow = true;
            g.add(pole, cloth);
            g.visible = false;
            scene.add(g);
            return g;
        }
        flag = createFlag();

        function createSmoke(pos) {
            const m = new THREE.Mesh(
                new THREE.SphereGeometry(Math.random()*0.2+0.1, 5, 5),
                new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 })
            );
            m.position.copy(pos).add(new THREE.Vector3((Math.random()-.5)*0.3, 0.2, (Math.random()-.5)*0.3));
            scene.add(m);
            particles.push({ mesh: m, life: 1.0, vel: new THREE.Vector3(0, 0.03, 0) });
        }

        // --- GLTF„É≠„Éº„Éâ ---
        new GLTFLoader().load('./model.glb', (gltf) => {
            model = gltf.scene;
            model.traverse(c => { if(c.isMesh) c.castShadow = true; });
            scene.add(model);
            
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip, i) => {
                actions[clip.name || `Motion${i}`] = mixer.clipAction(clip);
            });
            
            if (Object.values(actions).length > 2) specialAction = Object.values(actions)[2];
            
            // ‚òÖ„Ç™„Éº„Éó„Éã„É≥„Ç∞„Ç∑„Éº„Ç±„É≥„ÇπÈñãÂßã
            runOpeningSequence();
        });

        // --- ‚òÖ„Ç™„Éº„Éó„Éã„É≥„Ç∞„Ç∑„Éº„Ç±„É≥„Çπ ---
        async function runOpeningSequence() {
            debugLog("Opening: Initializing...");
            
            // 1. ÂàùÊúüÈÖçÁΩÆ
            model.position.set(0, 0, -12);
            model.rotation.set(0, 0, 0);
            
            camera.position.set(0, 1.5, 4);
            controls.target.set(0, 0.8, -12);
            controls.update();

            // 2. „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥3 (SpecialAction) „Çí„É´„Éº„ÉóÂÜçÁîü
            // „Å™„Åë„Çå„Å∞„Ç¢„Ç§„Éâ„É´
            let startAnim = actions['Motion 0'] || Object.values(actions)[0];
            if (specialAction) {
                startAnim = specialAction;
                // Âº∑Âà∂ÁöÑ„Å´„É´„Éº„ÉóË®≠ÂÆö (Âæå„ÅßÊàª„Åô)
                startAnim.setLoop(THREE.LoopRepeat);
            }
            startAnim.play();
            activeAction = startAnim;

            // 3. 2ÁßíÈñìÂæÖÊ©üÔºà‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºâ
            debugLog("Opening: Wait 2s...");
            await new Promise(r => setTimeout(r, 2000));

            // 4. „ÄåÔºÅ„Äç„Éù„ÉÉ„ÉóË°®Á§∫
            const pop = document.getElementById('emote-pop');
            pop.style.display = 'block';
            updateEmotePosition(); 
            
            // 0.5ÁßíË°®Á§∫
            await new Promise(r => setTimeout(r, 500));
            pop.style.display = 'none';

            // 5. Ëµ∞Ë°åÈñãÂßã (Z=-12 -> Z=-2)
            debugLog("Opening: Running...");
            const run = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(run, 0.2);
            
            isMoving = true;
            const targetZ = -2.0;
            const runSpeed = 0.15;

            while (model.position.z < targetZ) {
                model.position.z += runSpeed;
                if (Math.random() > 0.7) {
                    createSmoke(model.position.clone().add(new THREE.Vector3(0,0,-0.5)));
                }
                controls.target.set(0, 0.8, model.position.z);
                controls.update();
                await new Promise(r => requestAnimationFrame(r));
            }

            isMoving = false;

            // 6. „Ç¢„Ç§„Éâ„É´„Å´Êàª„Åô
            const idle = actions['Motion 0'] || Object.values(actions)[0];
            await fadeTo(idle, 0.3);

            // ‚òÖSpecialAction„ÅÆ„É´„Éº„ÉóË®≠ÂÆö„ÇíÂÖÉ„Å´Êàª„Åô (ÈÄöÂ∏∏„Ç≤„Éº„É†„Éó„É¨„Ç§Áî®)
            if (specialAction) {
                specialAction.setLoop(THREE.LoopOnce); 
            }

            // 7. „Ç´„É°„É©„Çí„Éó„É¨„Ç§Ë¶ñÁÇπ„Å∏ÁßªË°å
            debugLog("Ready!");
            const startCamPos = camera.position.clone();
            const endCamPos = DEFAULT_CAM_POS.clone();
            const steps = 60;
            
            for(let i=0; i<=steps; i++) {
                const t = i/steps;
                const ease = 1 - Math.pow(1 - t, 3);
                camera.position.lerpVectors(startCamPos, endCamPos, ease);
                
                const currentTarget = controls.target.clone();
                const endTarget = new THREE.Vector3(0, 0.5, -2);
                controls.target.lerpVectors(currentTarget, endTarget, 0.1);
                
                controls.update();
                await new Promise(r => requestAnimationFrame(r));
            }

            isOpening = false;
            controls.enabled = true;
            resetIdleTimer();
        }

        function updateEmotePosition() {
            if (!model) return;
            const pop = document.getElementById('emote-pop');
            if (pop.style.display === 'none') return;

            // „É¢„Éá„É´„ÅÆÈ†≠‰∏äÂ∑¶‰∏ä„ÅÇ„Åü„Çä„ÅÆÂ∫ßÊ®ô„ÇíÂèñÂæó
            const headPos = model.position.clone().add(new THREE.Vector3(-0.3, 2.0, 0));
            headPos.project(camera);

            const x = (headPos.x * .5 + .5) * window.innerWidth;
            const y = (-(headPos.y * .5) + .5) * window.innerHeight;

            pop.style.left = `${x}px`;
            pop.style.top = `${y}px`;
        }


        // --- ÂÖ•Âäõ„Ç§„Éô„É≥„Éà ---
        
        window.addEventListener('pointerdown', (e) => {
            if (isOpening) return; // ‚òÖÊìç‰Ωú„Éñ„É≠„ÉÉ„ÇØ
            if (e.target.closest('.ui-panel') || e.target.closest('#debug-panel') || window.isModalOpen) return;
            isDragging = false;
            pointerDownPos.set(e.clientX, e.clientY);
        });

        window.addEventListener('pointermove', (e) => {
            if (new THREE.Vector2(e.clientX, e.clientY).distanceTo(pointerDownPos) > 10) {
                isDragging = true;
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (isOpening) return; // ‚òÖÊìç‰Ωú„Éñ„É≠„ÉÉ„ÇØ
            if (e.target.closest('.ui-panel') || e.target.closest('#debug-panel') || window.isModalOpen) return;
            if (isDragging) return;

            // „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÂà§ÂÆö
            const now = Date.now();
            if (now - lastTapTime < 350) {
                tapStreak++;
            } else {
                tapStreak = 1;
            }
            lastTapTime = now;

            if (tapStreak === 3) {
                window.openDebug();
                debugLog("Debug Mode Opened");
                tapStreak = 0;
                return;
            }

            handleTapAction(e);
        });

        function handleTapAction(event) {
            if (!model || isProcessing) return;
            resetIdleTimer();

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersectsModel = raycaster.intersectObject(model, true);
            if (intersectsModel.length > 0) {
                playSpecialAction("Tap on Model");
                return;
            }

            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const point = intersects[0].point.clone();
                if (tapResetTimer) {
                    clearTimeout(tapResetTimer);
                    tapResetTimer = null;
                    startNavigation(point, true);
                } else {
                    tapResetTimer = setTimeout(() => {
                        tapResetTimer = null;
                        startNavigation(point, false);
                    }, 250);
                }
            }
        }

        // --- „É≠„Ç∏„ÉÉ„ÇØ ---

        function resetIdleTimer() {
            if (isOpening) return;
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(() => playSpecialAction("Idle Timeout"), 30000); 
        }

        async function playSpecialAction(source) {
            if (isProcessing || isMoving || !specialAction) return;
            debugLog(`Action: ${source}`);
            await fadeTo(specialAction, 0.5);
        }

        async function startNavigation(targetPos, boost) {
            isProcessing = true;
            isBoostMode = boost;
            resetIdleTimer();

            flag.position.copy(targetPos);
            flag.children[1].material.color.set(isBoostMode ? 0xffd700 : 0xff4757); 
            flag.visible = true;

            debugLog(isBoostMode ? "Dash!" : "Walking...");

            const toTarget = new THREE.Vector3().subVectors(targetPos, model.position);
            await turnTowards(Math.atan2(toTarget.x, toTarget.z), false);
            
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(runAction, 0.2);
            isMoving = true;
            
            const speed = isBoostMode ? window.params.dashSpeed : window.params.walkSpeed;
            const stopDist = isBoostMode ? 0.8 : 0.1;

            await new Promise(resolve => {
                const interval = setInterval(() => {
                    resetIdleTimer();
                    const dist = model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z));
                    
                    if (dist > 0.05) {
                        const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                        model.position.add(dir.setY(0).multiplyScalar(speed));
                        
                        if (isBoostMode && Math.random() > 0.3) {
                            createSmoke(model.position.clone().add(dir.multiplyScalar(-0.4)));
                        }
                    }

                    if (dist <= stopDist) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 16);
            });

            if (isBoostMode) {
                for(let i=0; i<15; i++) { 
                    model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(speed * 0.5));
                    await new Promise(r => requestAnimationFrame(r));
                }
                isMoving = false;
                await new Promise(r => setTimeout(r, 100));
                while (model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z)) > 0.1) {
                    model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(0.03));
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                isMoving = false;
            }
            flag.visible = false;

            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            await turnTowards(Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z), true);

            if (activeAction) activeAction.fadeOut(0.5);
            activeAction = null;
            isProcessing = false;
            resetIdleTimer();
            debugLog("Ready.");
        }

        async function turnTowards(targetAngle, isStepping) {
            const jumpAction = actions['ÂûÇÁõ¥„Ç∏„É£„É≥„Éó'] || Object.values(actions)[1];
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];

            if (isStepping) {
                await fadeTo(runAction, 0.2);
                while (true) {
                    let diff = targetAngle - model.rotation.y;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.05) break;
                    model.rotation.y += Math.sign(diff) * 0.08;
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                let diff = targetAngle - model.rotation.y;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                
                if (Math.abs(diff) > 0.3) {
                    await fadeTo(jumpAction, 0.1);
                    const startRot = model.rotation.y;
                    const steps = 30;
                    for (let i = 0; i <= steps; i++) {
                        model.rotation.y = startRot + (diff * (i/steps));
                        await new Promise(r => requestAnimationFrame(r));
                    }
                    await new Promise(r => setTimeout(r, 50));
                } else {
                    model.rotation.y = targetAngle;
                }
            }
        }

        async function fadeTo(next, dur) {
            if (!next || activeAction === next) return;
            if (activeAction) activeAction.fadeOut(dur);
            next.reset().setEffectiveWeight(1).fadeIn(dur).play();
            activeAction = next;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(1/60);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                p.mesh.position.add(p.vel);
                p.mesh.scale.multiplyScalar(1.03);
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            if (model) {
                if (blobShadow) {
                    blobShadow.position.set(model.position.x, 0.01, model.position.z);
                    const s = Math.max(0.1, 1.0 - model.position.y * 0.5);
                    blobShadow.scale.set(s, s, 1);
                    blobShadow.material.opacity = s * 0.6;
                }

                updateEmotePosition();

                if (!isOpening && !isDragging) {
                    const targetPos = model.position.clone().setY(0.5);
                    controls.target.lerp(targetPos, 0.1);
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
