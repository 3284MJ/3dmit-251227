<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Mitsuhashi Manual</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #e0e0e0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UIÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ */
        .ui-panel {
            position: absolute; left: 10px;
            background: rgba(0,0,0,0.6); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            border-radius: 4px; z-index: 100;
            backdrop-filter: blur(2px);
            user-select: none;
        }

        /* „Çπ„ÉÜ„Éº„Çø„Çπ„É≠„Ç∞ */
        #status-log {
            top: 10px;
            pointer-events: none;
        }

        /* Êìç‰ΩúË™¨Êòé„Éú„Çø„É≥ */
        #help-btn {
            top: 45px;
            cursor: pointer; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.3);
            transition: background 0.2s;
            display: flex; align-items: center; gap: 5px;
        }
        #help-btn:active { background: rgba(0,0,0,0.8); transform: translateY(1px); }
        #help-btn::before { content: "‚ùì"; font-size: 14px; }

        /* --- „É¢„Éº„ÉÄ„É´Ôºà„Éò„É´„ÉóÁîªÈù¢Ôºâ --- */
        .modal-overlay {
            display: none;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 2000;
            justify-content: center; align-items: center;
        }
        .modal-card {
            background: white; width: 85%; max-width: 320px;
            padding: 20px; border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; gap: 10px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal-header {
            font-size: 18px; font-weight: bold; color: #333;
            border-bottom: 2px solid #f0f0f0; padding-bottom: 10px; margin-bottom: 5px;
            display: flex; justify-content: space-between; align-items: center;
        }
        
        /* --- „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÁî®„Éù„ÉÉ„Éó„Ç¢„ÉÉ„Éó --- */
        #debug-popup {
            display: none;
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80%; max-width: 400px;
            background: rgba(0, 20, 40, 0.95);
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 20px;
            z-index: 3000;
            font-family: monospace;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #debug-content {
            white-space: pre-wrap;
            font-size: 12px;
            line-height: 1.4;
            margin-bottom: 15px;
        }
        .debug-title {
            font-size: 16px; font-weight: bold; border-bottom: 1px dashed #00ff00;
            margin-bottom: 10px; padding-bottom: 5px;
        }

        /* „Éò„É´„ÉóÁî®„Çπ„Çø„Ç§„É´ */
        .help-list-item {
            background: #f8f9fa; padding: 12px; border-radius: 8px;
            cursor: pointer; font-weight: bold; color: #555;
            display: flex; justify-content: space-between; align-items: center;
            transition: background 0.2s; border: 1px solid #eee;
        }
        .help-list-item:active { background: #e2e6ea; }
        .detail-view { display: none; text-align: left; }
        .detail-icon { font-size: 30px; text-align: center; margin: 15px 0; display: block; }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        .btn-close { background: #666; color: white; }
    </style>
</head>
<body>
    <div id="status-log" class="ui-panel">Status: Ready.</div>
    <div id="help-btn" class="ui-panel" onclick="openHelpMenu()">Êìç‰ΩúË™¨Êòé</div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <span id="modal-title">„É°„Éã„É•„Éº</span>
                <span style="cursor:pointer; font-size:20px;" onclick="closeModal()">√ó</span>
            </div>
            <div id="menu-list"></div>
            <div id="detail-area" class="detail-view">
                <div id="detail-content"></div>
                <div class="btn-group">
                    <button class="btn" style="background:#ddd" onclick="showList()">Êàª„Çã</button>
                    <button class="btn btn-close" onclick="closeModal()">Èñâ„Åò„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <div id="debug-popup">
        <div class="debug-title">DEBUG MODE</div>
        <div id="debug-content">Collecting data...</div>
        <button class="btn btn-close" onclick="closeDebug()">CLOSE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script>
        // --- UI / „Éò„É´„ÉóÈñ¢ÈÄ£ ---
        const helpContent = [
            { title: "Ê≠©„ÅÑ„Å¶ÁßªÂãï", icon: "üëÜ", desc: "Âú∞Èù¢„Çí„Äê1Âõû„Çø„ÉÉ„Éó„Äë" },
            { title: "„ÉÄ„ÉÉ„Ç∑„É•ÁßªÂãï", icon: "üëÜüëÜ", desc: "Âú∞Èù¢„Çí„Äê2ÂõûÈÄ£Êâì„Äë" },
            { title: "„Å≤„Åø„Å§„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥", icon: "ü§´", desc: "„Éü„ÉÑ„Éè„Ç∑„Åè„Çì„Çí„Çø„ÉÉ„Éó„ÄÅ„Åæ„Åü„ÅØÊîæÁΩÆ" },
            { title: "„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„Éâ", icon: "üîß", desc: "‰Ωï„ÇÇ„Å™„ÅÑ„Å®„Åì„Çç„Çí„Äê3ÂõûÈÄ£Êâì„Äë" }
        ];

        window.isModalOpen = false;
        window.openHelpMenu = function() {
            window.isModalOpen = true;
            document.getElementById('help-modal').style.display = 'flex';
            showList();
        };
        window.closeModal = function() {
            window.isModalOpen = false;
            document.getElementById('help-modal').style.display = 'none';
        };
        window.showList = function() {
            const listEl = document.getElementById('menu-list');
            const detailEl = document.getElementById('detail-area');
            const titleEl = document.getElementById('modal-title');
            detailEl.style.display = 'none'; listEl.style.display = 'flex'; listEl.style.flexDirection = 'column'; listEl.style.gap = '8px';
            titleEl.innerText = 'Êìç‰ΩúË™¨Êòé„É°„Éã„É•„Éº';
            listEl.innerHTML = '';
            helpContent.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'help-list-item';
                div.innerHTML = `${item.title} <span>‚ñ∂</span>`;
                div.onclick = () => {
                    listEl.style.display = 'none';
                    detailEl.style.display = 'block';
                    titleEl.innerText = item.title;
                    document.getElementById('detail-content').innerHTML = `<span class="detail-icon">${item.icon}</span><div>${item.desc}</div>`;
                };
                listEl.appendChild(div);
            });
        };

        // „Éá„Éê„ÉÉ„Ç∞ÁîªÈù¢Âà∂Âæ°
        window.isDebugOpen = false;
        window.openDebug = function(info) {
            window.isDebugOpen = true;
            const el = document.getElementById('debug-popup');
            el.style.display = 'block';
            document.getElementById('debug-content').innerText = info;
        };
        window.closeDebug = function() {
            window.isDebugOpen = false;
            document.getElementById('debug-popup').style.display = 'none';
        };
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const statusEl = document.getElementById('status-log');
        function debugLog(msg) { statusEl.innerText = "Status: " + msg; }

        // --- „Ç∑„Éº„É≥Ë®≠ÂÆö ---
        const scene = new THREE.Scene();
        // ËÉåÊôØËâ≤„ÇíÂ∞ë„ÅóÊòé„Çã„Åè„Åó„Å¶„Éï„Ç£„Éº„É´„Éâ„ÇíË¶ã„ÇÑ„Åô„Åè
        scene.background = new THREE.Color(0xe0e0e0);
        // „Éï„Ç©„Ç∞„ÇíÂÖ•„Çå„Å¶Â••Ë°å„ÅçÊÑü„ÇíÂá∫„Åô
        scene.fog = new THREE.Fog(0xe0e0e0, 10, 50);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true; // ÂΩ±„ÇíÊúâÂäπÂåñ
        document.body.appendChild(renderer.domElement);

        // --- „É©„Ç§„Éà ---
        scene.add(new THREE.AmbientLight(0xffffff, 1.5));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
        dirLight.position.set(5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024;
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // --- ‚òÖËøΩÂä†1: „Éï„Ç£„Éº„É´„ÉâÔºàÂÜÜÂΩ¢„ÉªÂçäÈÄèÊòéÔºâ ---
        // ÁØÑÂõ≤„ÅØ„Åä„Åæ„Åã„Åõ„Å®„ÅÆ„Åì„Å®„Å™„ÅÆ„Åß„ÄÅÂçäÂæÑ15„ÅÆÂÜÜ„Å´„Åó„Åæ„Åô
        const fieldGeometry = new THREE.CircleGeometry(15, 64);
        const fieldMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            transparent: true, 
            opacity: 0.4, 
            side: THREE.DoubleSide 
        });
        const ground = new THREE.Mesh(fieldGeometry, fieldMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- Â§âÊï∞ÂÆöÁæ© ---
        let mixer, model, blobShadow, flag;
        let actions = {}; 
        let activeAction = null; 
        let specialAction = null;
        let idleTimer = null;
        
        let isProcessing = false; 
        let isMoving = false;     
        let isBoostMode = false;     
        let particles = [];       

        // ÂÖ•ÂäõÂà∂Âæ°Áî®Â§âÊï∞
        let tapCount = 0;
        let tapResetTimer = null;
        let pointerDownPos = new THREE.Vector2();
        let isDragging = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // „Ç´„É°„É©Êìç‰Ωú
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Âú∞Èù¢„Å´ÊΩú„Çâ„Å™„ÅÑ„Çà„ÅÜ„Å´Âà∂Èôê

        // --- „Éò„É´„Éë„ÉºÈñ¢Êï∞Áæ§ ---

        // ÂΩ±„ÉÜ„ÇØ„Çπ„ÉÅ„É£
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            g.addColorStop(0, 'rgba(0,0,0,0.4)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, side: THREE.DoubleSide })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        blobShadow.position.y = 0.01;
        scene.add(blobShadow);

        // Êóó
        function createFlag() {
            const g = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 0.5;
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
            cloth.position.set(0.2, 0.8, 0);
            cloth.castShadow = true;
            g.add(pole, cloth);
            g.visible = false;
            scene.add(g);
            return g;
        }
        flag = createFlag();

        // ÁÖô„Ç®„Éï„Çß„ÇØ„Éà
        function createSmoke(pos) {
            const m = new THREE.Mesh(
                new THREE.SphereGeometry(Math.random()*0.2+0.1, 5, 5),
                new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 })
            );
            m.position.copy(pos).add(new THREE.Vector3((Math.random()-.5)*0.3, 0.2, (Math.random()-.5)*0.3));
            scene.add(m);
            particles.push({ mesh: m, life: 1.0, vel: new THREE.Vector3(0, 0.03, 0) });
        }

        // --- „É¢„Éá„É´Ë™≠„ÅøËæº„Åø ---
        new GLTFLoader().load('./model.glb', (gltf) => {
            model = gltf.scene;
            model.traverse(c => { if(c.isMesh) c.castShadow = true; });
            scene.add(model);
            
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip, i) => {
                actions[clip.name || `Motion${i}`] = mixer.clipAction(clip);
            });
            
            if (Object.values(actions).length > 2) specialAction = Object.values(actions)[2];
            
            resetIdleTimer();
            debugLog("Ready!");
        });

        // --- ‚òÖ‰øÆÊ≠£1: ÂÖ•Âäõ„Ç§„Éô„É≥„Éà„ÅÆÊõ∏„ÅçÊèõ„Åà ---
        // mousedown/touchstart „Åß„ÅØ„Å™„Åè pointer events „ÅßÁµ±‰∏Ä
        
        window.addEventListener('pointerdown', (e) => {
            if (e.target.closest('.ui-panel') || window.isModalOpen || window.isDebugOpen) return;
            
            isDragging = false;
            pointerDownPos.set(e.clientX, e.clientY);
        });

        window.addEventListener('pointermove', (e) => {
            // Â∞ë„Åó„Åß„ÇÇÂãï„ÅÑ„Åü„Çâ„Éâ„É©„ÉÉ„Ç∞„Å®„Åø„Å™„Åô
            if (new THREE.Vector2(e.clientX, e.clientY).distanceTo(pointerDownPos) > 10) {
                isDragging = true;
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (window.isModalOpen || window.isDebugOpen) return;
            if (e.target.closest('.ui-panel')) return;

            // „Éâ„É©„ÉÉ„Ç∞Êìç‰ΩúÔºà„Ç´„É°„É©ÁßªÂãïÔºâ„Å†„Å£„ÅüÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åó„Å™„ÅÑ
            if (isDragging) {
                return;
            }

            // --- „Åì„Åì„Åã„Çâ„Çø„ÉÉ„ÉóÂà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ ---
            handleTapLogic(e);
        });

        // „Çø„ÉÉ„ÉóÂà§ÂÆö„ÅÆ„Ç≥„Ç¢„É≠„Ç∏„ÉÉ„ÇØ
        function handleTapLogic(event) {
            // „Ç¢„ÇØ„Ç∑„Éß„É≥‰∏≠„Å™„ÇâÂèó„Åë‰ªò„Åë„Å™„ÅÑÔºà„Åü„Å†„Åó„Éá„Éê„ÉÉ„Ç∞Áî®ÈÄ£Êâì„ÅØÂà•ËÖπ„Å®„Åô„Çã„ÅãÔºü‰ªäÂõû„ÅØÂÆâÂÖ®„ÅÆ„Åü„ÇÅ„Éñ„É≠„ÉÉ„ÇØÔºâ
            if (!model || isProcessing) return;

            resetIdleTimer();

            // Â∫ßÊ®ôË®àÁÆó
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // 1. „É¢„Éá„É´„Å∏„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö
            const intersectsModel = raycaster.intersectObject(model, true);
            if (intersectsModel.length > 0) {
                playSpecialAction("Tap on Model");
                tapCount = 0; // „É¢„Éá„É´„Çø„ÉÉ„ÉóÊôÇ„ÅØÈÄ£Êâì„Ç´„Ç¶„É≥„Éà„É™„Çª„ÉÉ„Éà
                return;
            }

            // 2. Âú∞Èù¢„Å∏„ÅÆ„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                const point = intersects[0].point.clone();
                
                tapCount++;

                // „Çø„Ç§„Éû„Éº„ÅåÂãï„ÅÑ„Å¶„ÅÑ„Çå„Å∞„ÇØ„É™„Ç¢„Åó„Å¶ÂÜç„Çª„ÉÉ„ÉàÔºàÈÄ£ÊâìÂèó‰ªòÊúüÈñìÂª∂Èï∑Ôºâ
                if (tapResetTimer) clearTimeout(tapResetTimer);

                // ÈÄ£ÊâìÂà§ÂÆöÁî®„Çø„Ç§„Éû„Éº (400ms‰ª•ÂÜÖ„Å´Ê¨°„ÅÆ„Çø„ÉÉ„Éó„ÅåÊù•„Å™„Åë„Çå„Å∞Á¢∫ÂÆö)
                tapResetTimer = setTimeout(() => {
                    executeTapAction(point);
                    tapCount = 0; // Âá¶ÁêÜÂÆüË°åÂæå„Å´„É™„Çª„ÉÉ„Éà
                }, 400);

                // ‚òÖËøΩÂä†2: „Éà„É™„Éó„É´„Çø„ÉÉ„ÉóÔºà3ÂõûÔºâÊ§úÁü•„ÅßÂç≥ÊôÇÁô∫ÁÅ´
                if (tapCount === 3) {
                    clearTimeout(tapResetTimer); // „Çø„Ç§„Éû„Éº„Ç≠„É£„É≥„Çª„É´
                    showDebugInfo();
                    tapCount = 0;
                }
            }
        }

        // „Çø„ÉÉ„ÉóÂõûÊï∞„Å´Âøú„Åò„Åü„Ç¢„ÇØ„Ç∑„Éß„É≥ÂÆüË°å
        function executeTapAction(targetPoint) {
            if (tapCount === 1) {
                // „Ç∑„É≥„Ç∞„É´„Çø„ÉÉ„ÉóÔºöÊ≠©„Åç
                startNavigation(targetPoint, false);
            } else if (tapCount === 2) {
                // „ÉÄ„Éñ„É´„Çø„ÉÉ„ÉóÔºö„ÉÄ„ÉÉ„Ç∑„É•
                startNavigation(targetPoint, true);
            }
            // 3Âõû‰ª•‰∏ä„ÅØÂç≥ÊôÇÁô∫ÁÅ´„É≠„Ç∏„ÉÉ„ÇØ„ÅßÂá¶ÁêÜ„Åï„Çå„Çã„Åü„ÇÅ„Åì„Åì„Åß„ÅØÁÑ°Ë¶ñ
        }

        // ‚òÖËøΩÂä†2: „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâË°®Á§∫Èñ¢Êï∞
        function showDebugInfo() {
            if (isMoving || isProcessing) return; // ÁßªÂãï‰∏≠„ÅØÂá∫„Åï„Å™„ÅÑ
            
            const pos = model.position;
            const rot = THREE.MathUtils.radToDeg(model.rotation.y).toFixed(1);
            let activeName = "None";
            
            // ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥Âêç„ÇíÊé¢„Åô
            for (const [key, action] of Object.entries(actions)) {
                if (action === activeAction) activeName = key;
            }

            const info = 
`[System Status]
Platform: Web (Three.js r166)
TouchAction: Enabled

[Model Status]
Position: X=${pos.x.toFixed(2)}, Z=${pos.z.toFixed(2)}
Rotation: ${rot}¬∞
Active Action: ${activeName}
Total Actions: ${Object.keys(actions).length}

[Input]
Last Tap: Triple Tap (Debug Trigger)
Camera: OrbitControls Active
`;
            window.openDebug(info);
            debugLog("Debug Mode Opened.");
        }


        // --- ÁßªÂãï„Éª„Ç¢„ÇØ„Ç∑„Éß„É≥Âà∂Âæ°ÔºàÊó¢Â≠ò„É≠„Ç∏„ÉÉ„ÇØÔºâ ---

        function resetIdleTimer() {
            if (idleTimer) clearTimeout(idleTimer);
            idleTimer = setTimeout(() => playSpecialAction("Idle Timeout"), 30000); 
        }

        async function playSpecialAction(source) {
            if (isProcessing || isMoving || !specialAction) return;
            debugLog(`Action: ${source}`);
            await fadeTo(specialAction, 0.5);
        }

        async function startNavigation(targetPos, boost) {
            isProcessing = true;
            isBoostMode = boost;
            resetIdleTimer();

            // ÊóóË°®Á§∫
            flag.position.copy(targetPos);
            flag.children[1].material.color.set(isBoostMode ? 0xffd700 : 0xff4757); 
            flag.visible = true;

            debugLog(isBoostMode ? "Dash!" : "Walking...");

            // 1. Âêë„Åç„ÇíÂ§â„Åà„Çã
            const toTarget = new THREE.Vector3().subVectors(targetPos, model.position);
            await turnTowards(Math.atan2(toTarget.x, toTarget.z), false);
            
            // 2. ÁßªÂãïÈñãÂßã
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(runAction, 0.2);
            isMoving = true;
            
            const speed = isBoostMode ? 0.12 : 0.06;
            const stopDist = isBoostMode ? 0.8 : 0.1;

            await new Promise(resolve => {
                const interval = setInterval(() => {
                    resetIdleTimer();
                    const dist = model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z));
                    
                    if (dist > 0.05) {
                        const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                        model.position.add(dir.setY(0).multiplyScalar(speed));
                        
                        // „ÉÄ„ÉÉ„Ç∑„É•ÊôÇ„ÅÆÁÖô
                        if (isBoostMode && Math.random() > 0.3) {
                            createSmoke(model.position.clone().add(dir.multiplyScalar(-0.4)));
                        }
                    }

                    if (dist <= stopDist) {
                        clearInterval(interval);
                        resolve();
                    }
                }, 16);
            });

            // 3. ÂÅúÊ≠¢Âá¶ÁêÜÔºà„ÉÄ„ÉÉ„Ç∑„É•ÊôÇ„ÅØË°å„ÅçÈÅé„Åé„ÇãÊºîÂá∫Ôºâ
            if (isBoostMode) {
                for(let i=0; i<15; i++) { 
                    model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(0.04));
                    await new Promise(r => requestAnimationFrame(r));
                }
                isMoving = false;
                await new Promise(r => setTimeout(r, 100));
                // Êàª„Çã
                while (model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z)) > 0.1) {
                    model.position.add(new THREE.Vector3().subVectors(targetPos, model.position).normalize().multiplyScalar(0.03));
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                isMoving = false;
            }
            flag.visible = false;

            // 4. „Ç´„É°„É©Âêë„Åç„Å´Êàª„Çã
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            await turnTowards(Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z), true);

            if (activeAction) activeAction.fadeOut(0.5);
            activeAction = null;
            isProcessing = false;
            resetIdleTimer();
            debugLog("Ready.");
        }

        async function turnTowards(targetAngle, isStepping) {
            const jumpAction = actions['ÂûÇÁõ¥„Ç∏„É£„É≥„Éó'] || Object.values(actions)[1];
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];

            if (isStepping) {
                await fadeTo(runAction, 0.2);
                while (true) {
                    let diff = targetAngle - model.rotation.y;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.05) break;
                    model.rotation.y += Math.sign(diff) * 0.08;
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                // „Ç∏„É£„É≥„ÉóÂõûËª¢
                let diff = targetAngle - model.rotation.y;
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                
                // ËßíÂ∫¶„ÅåÂ§ß„Åç„ÅÑÂ†¥Âêà„ÅÆ„Åø„Ç∏„É£„É≥„Éó„Åô„Çã
                if (Math.abs(diff) > 0.3) {
                    await fadeTo(jumpAction, 0.1);
                    const startRot = model.rotation.y;
                    const steps = 30;
                    for (let i = 0; i <= steps; i++) {
                        model.rotation.y = startRot + (diff * (i/steps));
                        await new Promise(r => requestAnimationFrame(r));
                    }
                    await new Promise(r => setTimeout(r, 50));
                } else {
                    model.rotation.y = targetAngle;
                }
            }
        }

        async function fadeTo(next, dur) {
            if (!next || activeAction === next) return;
            if (activeAction) activeAction.fadeOut(dur);
            next.reset().setEffectiveWeight(1).fadeIn(dur).play();
            activeAction = next;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(1/60);

            // ÁÖôÊõ¥Êñ∞
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.03;
                p.mesh.position.add(p.vel);
                p.mesh.scale.multiplyScalar(1.03);
                p.mesh.material.opacity = p.life;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            // ÂΩ±ËøΩÂæì
            if (model && blobShadow) {
                blobShadow.position.set(model.position.x, 0.01, model.position.z);
                const s = Math.max(0.1, 1.0 - model.position.y * 0.5);
                blobShadow.scale.set(s, s, 1);
                blobShadow.material.opacity = s * 0.6;
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
