<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer - Mitsuhashi Debug v1.1.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; touch-action: none; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UIÂÖ±ÈÄö„Çπ„Çø„Ç§„É´ */
        .ui-panel {
            position: absolute; left: 10px;
            background: rgba(0,0,0,0.6); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            border-radius: 4px; z-index: 100;
            backdrop-filter: blur(2px);
        }

        /* „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞ */
        #debug-log {
            top: 10px;
            pointer-events: none;
        }

        /* Êìç‰ΩúË™¨Êòé„Éú„Çø„É≥ */
        #help-btn {
            top: 45px;
            cursor: pointer; pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.3);
            display: flex; align-items: center; gap: 5px;
        }

        /* --- „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ (ÂàùÊúüÈùûË°®Á§∫) --- */
        #debug-panel {
            display: none; /* „Éà„É™„Éó„É´„ÇØ„É™„ÉÉ„ÇØ„ÅßË°®Á§∫ */
            position: absolute; top: 10px; right: 10px; left: auto;
            width: 220px; background: rgba(0,0,0,0.85); color: #0f0;
            padding: 15px; border-radius: 8px; font-family: monospace;
            border: 1px solid #0f0;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
            z-index: 3000;
        }
        #debug-panel h3 { margin: 0 0 10px 0; font-size: 14px; border-bottom: 1px solid #0f0; padding-bottom: 5px; }
        .debug-row { margin-bottom: 12px; display: flex; flex-direction: column; gap: 4px; }
        .debug-row label { font-size: 11px; color: #ccc; display: flex; justify-content: space-between; }
        .debug-btn {
            background: #003300; color: #0f0; border: 1px solid #0f0;
            padding: 8px; margin-top: 5px; cursor: pointer; width: 100%;
            font-family: monospace; transition: background 0.2s;
        }
        .debug-btn:active { background: #0f0; color: #000; }
        .close-debug { text-align: right; cursor: pointer; margin-bottom: 5px; font-size: 16px; }

        /* --- „É¢„Éº„ÉÄ„É´Ôºà„Éò„É´„ÉóÁîªÈù¢Ôºâ --- */
        .modal-overlay {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); z-index: 2000;
            justify-content: center; align-items: center;
        }
        .modal-card {
            background: white; width: 85%; max-width: 320px;
            padding: 20px; border-radius: 15px;
            display: flex; flex-direction: column; gap: 10px;
        }
        .modal-header {
            font-size: 18px; font-weight: bold; color: #333;
            border-bottom: 2px solid #f0f0f0; padding-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .help-list-item {
            background: #f8f9fa; padding: 12px; border-radius: 8px;
            cursor: pointer; font-weight: bold; color: #555;
            display: flex; justify-content: space-between; align-items: center;
            border: 1px solid #eee; margin-bottom: 8px;
        }
        .detail-view { display: none; }
        .detail-icon { font-size: 30px; text-align: center; margin: 15px 0; display: block; }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .btn { flex: 1; padding: 10px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; }
        .btn-close { background: #666; color: white; }
        .btn-back { background: #ddd; color: #333; }
    </style>
</head>
<body>
    <div id="debug-log" class="ui-panel">Status: Ready.</div>
    <div id="help-btn" class="ui-panel" onclick="openHelpMenu()">Êìç‰ΩúË™¨Êòé</div>

    <div id="debug-panel">
        <div class="close-debug" onclick="toggleDebugPanel()">[x] Close</div>
        <h3>üõ†Ô∏è MITSUHASHI DEBUG</h3>
        
        <div class="debug-row">
            <label>Walk Speed <span id="val-walk">0.06</span></label>
            <input type="range" id="inp-walk" min="0.01" max="0.2" step="0.01" value="0.06">
        </div>

        <div class="debug-row">
            <label>Dash Speed <span id="val-dash">0.12</span></label>
            <input type="range" id="inp-dash" min="0.05" max="0.5" step="0.01" value="0.12">
        </div>

        <button class="debug-btn" onclick="resetCameraPosition()">Reset Camera</button>
        <button class="debug-btn" onclick="resetMitsuhashi()">Reset Mitsuhashi</button>
    </div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-card">
            <div class="modal-header">
                <span id="modal-title">„É°„Éã„É•„Éº</span>
                <span style="cursor:pointer; font-size:20px;" onclick="closeModal()">√ó</span>
            </div>
            <div id="menu-list"></div>
            <div id="detail-area" class="detail-view">
                <div id="detail-content"></div>
                <div class="btn-group">
                    <button class="btn btn-back" onclick="showList()">Êàª„Çã</button>
                    <button class="btn btn-close" onclick="closeModal()">Èñâ„Åò„Çã</button>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script>
        // --- Ë®≠ÂÆöÂÄ§ÁÆ°ÁêÜ (v1.1.0) ---
        const CONFIG = {
            walkSpeed: 0.06,
            boostSpeed: 0.12
        };

        // UI„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
        document.getElementById('inp-walk').addEventListener('input', (e) => {
            CONFIG.walkSpeed = parseFloat(e.target.value);
            document.getElementById('val-walk').innerText = CONFIG.walkSpeed;
        });
        document.getElementById('inp-dash').addEventListener('input', (e) => {
            CONFIG.boostSpeed = parseFloat(e.target.value);
            document.getElementById('val-dash').innerText = CONFIG.boostSpeed;
        });

        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            panel.style.display = (panel.style.display === 'none' || panel.style.display === '') ? 'block' : 'none';
        }

        // --- „Éò„É´„Éó„Éá„Éº„ÇøÂÆöÁæ© ---
        const helpContent = [
            { title: "Ê≠©„ÅÑ„Å¶ÁßªÂãï", icon: "üëÜ", desc: "Âú∞Èù¢„Çí„Äê1Âõû„Çø„ÉÉ„Éó„Äë„Åô„Çã„Å®„ÄÅ„Éü„ÉÑ„Éè„Ç∑„Åè„Çì„Åå„Åù„ÅÆÂ†¥ÊâÄ„Åæ„Åß„Éà„Ç≥„Éà„Ç≥Ê≠©„ÅÑ„Å¶ÁßªÂãï„Åó„Åæ„Åô„ÄÇ" },
            { title: "„ÉÄ„ÉÉ„Ç∑„É•ÁßªÂãï", icon: "üëÜüëÜ", desc: "Âú∞Èù¢„Çí„Äê„ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„Äë„Åô„Çã„Å®„ÄÅÁÖô„Çí‰∏ä„Åí„Å¶Áåõ„ÉÄ„ÉÉ„Ç∑„É•ÔºÅ" },
            { title: "ÔºüÔºüÔºü", icon: "üîí", desc: "‰Ωï„ÇÇ„Å™„ÅÑ„Å®„Åì„Çç„ÇíÁ¥†Êó©„Åè3Âõû„Çø„ÉÉ„Éó„Åô„Çã„Å®‚Ä¶ÔºüÔºàÈñãÁô∫ËÄÖÁî®„É¢„Éº„ÉâÔºâ" }
        ];

        window.isModalOpen = false;
        window.openHelpMenu = function() {
            window.isModalOpen = true;
            document.getElementById('help-modal').style.display = 'flex';
            showList();
        };
        window.closeModal = function() {
            window.isModalOpen = false;
            document.getElementById('help-modal').style.display = 'none';
        };
        window.showList = function() {
            const listEl = document.getElementById('menu-list');
            const detailEl = document.getElementById('detail-area');
            const titleEl = document.getElementById('modal-title');
            detailEl.style.display = 'none';
            listEl.style.display = 'flex';
            listEl.style.flexDirection = 'column';
            listEl.style.gap = '8px';
            titleEl.innerText = 'Êìç‰ΩúË™¨Êòé„É°„Éã„É•„Éº';
            listEl.innerHTML = '';
            helpContent.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'help-list-item';
                div.innerText = item.title;
                div.onclick = () => showDetail(index);
                listEl.appendChild(div);
            });
        };
        window.showDetail = function(index) {
            const listEl = document.getElementById('menu-list');
            const detailEl = document.getElementById('detail-area');
            const contentEl = document.getElementById('detail-content');
            const titleEl = document.getElementById('modal-title');
            const item = helpContent[index];
            listEl.style.display = 'none';
            detailEl.style.display = 'block';
            titleEl.innerText = item.title;
            contentEl.innerHTML = `<span class="detail-icon">${item.icon}</span><div class="detail-desc">${item.desc}</div>`;
        };
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const logElement = document.getElementById('debug-log');
        function debugLog(msg) { logElement.innerText = "Status: " + msg; }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 2.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ visible: false }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let mixer, model, blobShadow, flag;
        let actions = {}; 
        let activeAction = null; 
        
        let isProcessing = false; 
        let isMoving = false;     
        let isBoostMode = false;  
        let cancelMove = false; // Âº∑Âà∂ÂÅúÊ≠¢Áî®„Éï„É©„Ç∞
        let tapTimer = null;      
        let particles = [];       

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- „Éá„Éê„ÉÉ„Ç∞Ê©üËÉΩ (Global Scope„Å∏„ÅÆÈú≤Âá∫) ---
        window.resetCameraPosition = function() {
            camera.position.set(0, 5, 10);
            controls.target.set(0, 0, 0);
            controls.update();
            debugLog("Camera Reset.");
        };

        window.resetMitsuhashi = function() {
            if (!model) return;
            // ÁßªÂãï‰∏≠„ÅÆ„É´„Éº„Éó„ÇíÊ≠¢„ÇÅ„Çã„Åü„ÇÅ„Å´„Ç≠„É£„É≥„Çª„É´Áî®„ÅÆ„Éï„É©„Ç∞„ÇíÁ´ã„Å¶„Çã
            cancelMove = true;
            
            // ‰ΩçÁΩÆ„Å®ÂõûËª¢„ÅÆ„É™„Çª„ÉÉ„Éà
            model.position.set(0, 0, 0);
            model.rotation.set(0, 0, 0);
            
            // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÅÆ„É™„Çª„ÉÉ„Éà
            if (activeAction) activeAction.fadeOut(0.2);
            activeAction = null;
            
            isProcessing = false;
            isMoving = false;
            flag.visible = false;
            debugLog("Mitsuhashi Reset.");
        };

        // ÂΩ±
        function createShadowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(0,0,0,0.6)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }
        blobShadow = new THREE.Mesh(
            new THREE.PlaneGeometry(1.2, 1.2),
            new THREE.MeshBasicMaterial({ map: createShadowTexture(), transparent: true, depthWrite: false, side: THREE.DoubleSide })
        );
        blobShadow.rotation.x = -Math.PI / 2;
        blobShadow.position.y = 0.005;
        scene.add(blobShadow);

        // Êóó
        function createFlag() {
            const group = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            pole.position.y = 0.5;
            const cloth = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.02), new THREE.MeshStandardMaterial({ color: 0xff4757 }));
            cloth.position.set(0.2, 0.8, 0);
            group.add(pole, cloth);
            group.visible = false;
            scene.add(group);
            return group;
        }
        flag = createFlag();

        // ÁÖô‰ΩúÊàê
        function createSmoke(spawnPos) {
            const size = Math.random() * 0.2 + 0.15;
            const geo = new THREE.SphereGeometry(size, 6, 6);
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.5 });
            const p = new THREE.Mesh(geo, mat);
            p.position.set(spawnPos.x + (Math.random() - 0.5) * 0.2, 0.2, spawnPos.z + (Math.random() - 0.5) * 0.2);
            scene.add(p);
            particles.push({ mesh: p, life: 1.0, velocity: new THREE.Vector3(0, 0.03, 0) });
        }

        new GLTFLoader().load('./model.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip) => {
                actions[clip.name || `Motion`] = mixer.clipAction(clip);
            });
            debugLog("Ready! (Triple click for Debug)");
        });

        // --- ÂÖ•Âäõ„Éè„É≥„Éâ„É© („Éà„É™„Éó„É´„ÇØ„É™„ÉÉ„ÇØÂØæÂøú) ---
        let clickCount = 0;
        let clickResetTimer = null;

        function handleInput(event) {
            if (window.isModalOpen) return;
            // UI„Éë„Éç„É´Êìç‰ΩúÊôÇ„ÅØÁÑ°Ë¶ñ
            if (event.target.closest('.ui-panel') || event.target.closest('#debug-panel')) return;

            // --- „Éà„É™„Éó„É´„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö„É≠„Ç∏„ÉÉ„ÇØ ---
            clickCount++;
            if (clickCount === 1) {
                clickResetTimer = setTimeout(() => { clickCount = 0; }, 500); // 500ms‰ª•ÂÜÖ„Å´3Âõû
            }
            if (clickCount === 3) {
                clearTimeout(clickResetTimer);
                clickCount = 0;
                toggleDebugPanel();
                debugLog("Debug Mode Toggled!");
                return; // „Éá„Éê„ÉÉ„Ç∞Âàá„ÇäÊõø„ÅàÊôÇ„ÅØÁßªÂãï„Åï„Åõ„Å™„ÅÑ
            }
            // ----------------------------------

            // ÁßªÂãï‰∏≠„ÅÆÂÖ•Âäõ„ÅØÁÑ°Ë¶ñÔºà„Åü„Å†„Åó„Éà„É™„Éó„É´„ÇØ„É™„ÉÉ„ÇØÂà§ÂÆö„ÅØÈÄöÈÅé„Åï„Åõ„Çã„Åü„ÇÅ„ÄÅ„Åì„Åì„Å´ÈÖçÁΩÆÔºâ
            if (!model || isProcessing) return;

            let clientX = event.touches ? event.touches[0].clientX : event.clientX;
            let clientY = event.touches ? event.touches[0].clientY : event.clientY;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);

            if (intersects.length > 0) {
                const point = intersects[0].point.clone();

                if (tapTimer == null) {
                    tapTimer = setTimeout(() => {
                        tapTimer = null;
                        startNavigation(point, false); 
                    }, 250); 
                } else {
                    clearTimeout(tapTimer);
                    tapTimer = null;
                    startNavigation(point, true); 
                }
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, { passive: false });

        async function startNavigation(targetPos, boost) {
            isProcessing = true;
            isBoostMode = boost;
            cancelMove = false; // „Ç≠„É£„É≥„Çª„É´„Éï„É©„Ç∞ÂàùÊúüÂåñ
            
            flag.position.copy(targetPos);
            flag.children[1].material.color.set(isBoostMode ? 0xffd700 : 0xff4757); 
            flag.visible = true;

            debugLog(isBoostMode ? "BOOST MODE!" : "Walking...");

            // Ë®≠ÂÆöÂÄ§„Çí‰ΩøÁî®
            const speed = isBoostMode ? CONFIG.boostSpeed : CONFIG.walkSpeed;

            // 1. ÊñπÂêëËª¢Êèõ
            const toTarget = new THREE.Vector3().subVectors(targetPos, model.position);
            const targetAngle = Math.atan2(toTarget.x, toTarget.z);
            await turnTowards(targetAngle, false);
            
            if (cancelMove) return; // „É™„Çª„ÉÉ„Éà„Åï„Çå„Åü„Çâ‰∏≠Êñ≠

            await new Promise(r => setTimeout(r, 200));

            // 2. ÁßªÂãï
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];
            await fadeTo(runAction, 0.2);
            isMoving = true;
            
            await new Promise(resolve => {
                const check = setInterval(() => {
                    if (cancelMove) {
                        clearInterval(check);
                        resolve();
                        return;
                    }

                    // Ë®≠ÂÆöÂÄ§Ôºà„É™„Ç¢„É´„Çø„Ç§„É†ÂèçÊò†„ÅÆ„Åü„ÇÅ„É´„Éº„ÉóÂÜÖ„ÅßÂèÇÁÖßÔºâ
                    const currentSpeed = isBoostMode ? CONFIG.boostSpeed : CONFIG.walkSpeed;
                    
                    const currentDist = model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z));
                    const stopDist = isBoostMode ? 0.8 : 0.1;
                    
                    if (currentDist > 0.05) {
                        const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                        model.position.add(dir.setY(0).multiplyScalar(currentSpeed));
                        
                        if (isBoostMode) {
                            const backOffset = dir.clone().multiplyScalar(-0.4);
                            const smokePos = model.position.clone().add(backOffset);
                            if (Math.random() > 0.3) createSmoke(smokePos);
                        }
                    }

                    if (currentDist <= stopDist) {
                        clearInterval(check);
                        resolve();
                    }
                }, 16);
            });

            if (cancelMove) return;

            // 3. Âà∞ÁùÄÂæå
            if (isBoostMode) {
                // „Ç™„Éº„Éê„Éº„É©„É≥
                for(let i=0; i<20; i++) { 
                    if (cancelMove) break;
                    const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                    model.position.add(dir.multiplyScalar(0.04)); 
                    await new Promise(r => requestAnimationFrame(r));
                }
                
                isMoving = false;
                await new Promise(r => setTimeout(r, 200));

                // Êàª„ÇãÂãï‰Ωú
                while (model.position.distanceTo(new THREE.Vector3(targetPos.x, model.position.y, targetPos.z)) > 0.1) {
                    if (cancelMove) break;
                    const dir = new THREE.Vector3().subVectors(targetPos, model.position).normalize();
                    model.position.add(dir.multiplyScalar(0.03)); 
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                isMoving = false;
            }

            flag.visible = false;

            if (cancelMove) return;

            // 4. Ë∂≥Ë∏è„ÅøÂõûËª¢
            const camPos = new THREE.Vector3();
            camera.getWorldPosition(camPos);
            const finalAngle = Math.atan2(camPos.x - model.position.x, camPos.z - model.position.z);
            await turnTowards(finalAngle, true);

            if (activeAction) activeAction.fadeOut(0.5);
            activeAction = null;
            isProcessing = false;
            debugLog("Ready.");
        }

        async function turnTowards(targetAngle, isStepping) {
            if (cancelMove) return;
            const jumpAction = actions['ÂûÇÁõ¥„Ç∏„É£„É≥„Éó'] || Object.values(actions)[1];
            const runAction = actions['Ëµ∞Ë°å'] || Object.values(actions)[0];

            if (isStepping) {
                await fadeTo(runAction, 0.2);
                while (true) {
                    if (cancelMove) break;
                    let diff = targetAngle - model.rotation.y;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.05) break;
                    model.rotation.y += Math.sign(diff) * 0.06;
                    await new Promise(r => requestAnimationFrame(r));
                }
            } else {
                while (true) {
                    if (cancelMove) break;
                    let diff = targetAngle - model.rotation.y;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.1) break;
                    const step = Math.sign(diff) * Math.min(Math.abs(diff), Math.PI/3);
                    await fadeTo(jumpAction, 0.1);
                    const startR = model.rotation.y;
                    const startTime = performance.now();
                    await new Promise(res => {
                        function r() {
                            if (cancelMove) { res(); return; }
                            const p = Math.min((performance.now() - startTime) / 800, 1);
                            model.rotation.y = startR + step * p;
                            if (p < 1) requestAnimationFrame(r); else res();
                        }
                        r();
                    });
                }
            }
        }

        async function fadeTo(nextAction, duration) {
            if (!nextAction || activeAction === nextAction) return;
            if (activeAction) activeAction.fadeOut(duration);
            nextAction.reset().setEffectiveWeight(1).fadeIn(duration).play();
            activeAction = nextAction;
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = 1/60;
            if (mixer) mixer.update(delta);

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= 0.02;
                p.mesh.position.add(p.velocity);
                p.mesh.material.opacity = p.life;
                p.mesh.scale.multiplyScalar(1.05);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            if (model && blobShadow) {
                blobShadow.position.set(model.position.x, 0.005, model.position.z);
                blobShadow.material.opacity = Math.max(0, 1.0 - model.position.y * 0.4);
                blobShadow.scale.setScalar(Math.max(0.1, 1.0 - model.position.y * 0.3));
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
